# This file was generated. Do not edit manually.

schema {
    query: DotaQuery
    mutation: DotaMutation
    subscription: DotaSubscription
}

union LiveEventType = LiveEventMatchDireTideStompType | LiveEventPlayerDireTideCandyScoredType | LiveEventPlayerHeroAssistsType | LiveEventPlayerHeroBuildingDamageType | LiveEventPlayerHeroDewardType | LiveEventPlayerHeroDotaPlusLevelType | LiveEventPlayerHeroExpPerMinuteType | LiveEventPlayerHeroGoldPerMinuteType | LiveEventPlayerHeroHealingType | LiveEventPlayerHeroHeroDamageType | LiveEventPlayerHeroHighImpType | LiveEventPlayerHeroItemPurchaseType | LiveEventPlayerHeroKillsType | LiveEventPlayerHeroWinStreakType | LiveEventPlayerRampageType | LiveEventPlayerRankUpType | LiveEventPlayerWinStreakType | LiveEventProPlayerLiveType

union MatchGroupByType = MatchGroupByAssistsType | MatchGroupByAwardType | MatchGroupByClusterType | MatchGroupByDateDayType | MatchGroupByDeathsType | MatchGroupByDurationMinutesType | MatchGroupByFactionType | MatchGroupByGameModeType | MatchGroupByGameVersionType | MatchGroupByGoldPerMinuteType | MatchGroupByHeroPerformanceType | MatchGroupByHeroType | MatchGroupByIsIntentionalFeedingType | MatchGroupByIsLeagueType | MatchGroupByIsLeaverType | MatchGroupByIsPartyType | MatchGroupByIsRandomType | MatchGroupByIsSeriesType | MatchGroupByIsStatsType | MatchGroupByIsVictoryType | MatchGroupByKillsType | MatchGroupByLaneType | MatchGroupByLeagueIdType | MatchGroupByLevelType | MatchGroupByLobbyTypeType | MatchGroupByPositionType | MatchGroupByRegionType | MatchGroupByRoamLaneType | MatchGroupByRoleType | MatchGroupBySteamAccountIdAgainstTeamType | MatchGroupBySteamAccountIdHeroIdAgainstTeamType | MatchGroupBySteamAccountIdHeroIdType | MatchGroupBySteamAccountIdHeroIdWithTeamType | MatchGroupBySteamAccountIdType | MatchGroupBySteamAccountIdWithTeamType | MatchGroupByTeamType | MatchGroupByTotalKillsType

type AbilityActiveListType {
    ability0: Short
    ability1: Short
    ability2: Short
    ability3: Short
    ability4: Short
    ability5: Short
    ability6: Short
    ability7: Short
    time: Int!
}

type AbilityAttributeType {
    linkedSpecialBonusAbilityId: Short
    name: String
    requiresScepter: Boolean
    value: String
}

type AbilityCustomGameLanguageType {
    description: String
    displayName: String
}

type AbilityCustomGameType {
    abilityName: String
    id: Short
    language: AbilityCustomGameLanguageType
    name: String
}

type AbilityLanguageType {
    aghanimDescription: String
    attributes: [String]
    description: [String]
    displayName: String
    lore: String
    notes: [String]
    shardDescription: String
}

type AbilityLearnEventsType {
    abilityId: Short
    isMaxLevel: Boolean
    isTalent: Boolean
    isUltimate: Boolean
    level: Int!
    levelObtained: Int!
    time: Int!
}

type AbilityStatType {
    abilityId: Short
    behavior: Long
    castPoint: [Float]
    castRange: [Int]
    castRangeBuffer: [Int]
    channelTime: [Float]
    chargeRestoreTime: String
    charges: String
    cooldown: [Float]
    damage: [Float]
    dispellable: AbilityDispellEnum
    displayAdditionalHeroes: Boolean
    duration: String
    fightRecapLevel: Short
    hasScepterUpgrade: Boolean
    hotKeyOverride: String
    isGrantedByScepter: Boolean
    isGrantedByShard: Boolean
    isOnCastbar: Boolean
    isOnLearnbar: Boolean
    isUltimate: Boolean
    levelsBetweenUpgrades: Byte
    linkedAbilityId: Short
    manaCost: [Float]
    maxLevel: Byte
    modifierSupportBonus: Short
    modifierSupportValue: Float
    requiredLevel: Byte
    spellImmunity: Int
    type: Int
    unitDamageType: Int
    unitTargetFlags: Long
    unitTargetTeam: Int
    unitTargetType: Long
}

type AbilityType {
    attributes: [AbilityAttributeType]
    id: Short
    isTalent: Boolean
    language: AbilityLanguageType
    name: String
    stat: AbilityStatType
    uri: String
}

type AbilityUsedEventsType {
    abilityId: Short
    attacker: Short
    target: Short
    time: Int!
}

type AdminMutation {
    deleteProSteamAccount(request: DeleteProSteamAccountRequestType!): Boolean
    mergeProSteamAccount(request: [MergeProSteamAccountRequestType]!): Boolean
}

type AdminQuery {
    "Returns a list of Stratz blogs."
    apiMemoryReport: [String]
}

type AghanimLabDepthListAscensionAbilitiesObjectType {
    abilityId: Short
    modifierId: Short
    type: AghanimLabDepthListAscensionAbilitiesEnum
}

type AghanimLabHeroAbilityType {
    customAbilityId: Short
    difficulty: AghanimLabMatchDifficultyEnum
    heroId: Short
    matchCount: Int
    pickCount: Int
    winCount: Int
}

type AghanimLabHeroCompositionType {
    difficulty: AghanimLabMatchDifficultyEnum
    duration: Int
    heroId1: Short
    heroId2: Short
    heroId3: Short
    heroId4: Short
    matchCount: Int
    wilsonScore: Decimal
    winCount: Int
}

type AghanimLabHeroWinRateType {
    difficulty: AghanimLabMatchDifficultyEnum
    heroId: Short
    matchCount: Int
    winCount: Int
}

type AghanimLabMatchDepthListType {
    ascensionAbilities: [AghanimLabDepthListAscensionAbilitiesObjectType]
    selectedElite: Boolean
    selectedEncounter: AghanimLabDepthListEncounterEnum
    selectedEncounterEnum: Byte
    selectedHidden: Boolean
    selectedReward: AghanimLabDepthListRewardEnum
    unselectedElite: Boolean
    unselectedEncounter: AghanimLabDepthListEncounterEnum
    unselectedHidden: Boolean
    unselectedReward: AghanimLabDepthListRewardEnum
}

type AghanimLabMatchType {
    arcaneFragments: Short
    battlePoints: Short
    clusterId: Short
    depth: Byte
    depthList: [AghanimLabMatchDepthListType]
    didWin: Boolean
    difficulty: AghanimLabMatchDifficultyEnum
    durationSeconds: Short
    endDateTime: Long
    gameMode: Byte
    goldBags: Short
    id: Long
    lobbyType: Byte
    numDeaths: Short
    numHumanPlayers: Byte
    numKills: Short
    players(
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long
    ): [AghanimLabPlayerSeasonOneType]
    regionId: Byte
    replaySalt: Long
    score: Int
    seed: Int
    startDateTime: Long
}

type AghanimLabPlayerBlessingObjectType {
    type: AghanimLabPlayerBlessingEnum
    value: Short
}

type AghanimLabPlayerDepthListType {
    goldBags: Short
    kills: Short
    level: Byte
    networth: Int
    numDeaths: Short
    rarity: Byte
    selectedRewardAbility(
        "The language id to include in this query, excluding all results that do not have this language."
        langaugeId: Int
    ): AbilityCustomGameType
    selectedRewardAbilityId: Short
    selectedRewardImageAbilityId: Short
    unSelectedRewardAbility1(
        "The language id to include in this query, excluding all results that do not have this language."
        langaugeId: Int
    ): AbilityCustomGameType
    unSelectedRewardAbility2(
        "The language id to include in this query, excluding all results that do not have this language."
        langaugeId: Int
    ): AbilityCustomGameType
    unSelectedRewardAbilityId1: Short
    unSelectedRewardAbilityId2: Short
}

type AghanimLabPlayerSeasonOneType {
    arcaneFragments: Short
    blessings: [AghanimLabPlayerBlessingObjectType]
    bonusArcaneFragments: Short
    deaths: Long
    experiencePerMinute: Short
    goldBags: Short
    goldPerMinute: Short
    goldSpent: Int
    hero: HeroType
    heroId: Short
    isVictory: Boolean!
    item0Id: Short
    item1Id: Short
    item2Id: Short
    item3Id: Short
    item4Id: Short
    item5Id: Short
    leaverStatus: Byte
    level: Byte
    matchId: Long
    networth: Int
    neutral0Id: Long
    neutralItemId: Short
    numLastHits: Short
    partyId: Byte
    playerDepthList: [AghanimLabPlayerDepthListType]
    playerSlot: Byte
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type AghanimLabRoomType {
    deathCount: Int
    difficulty: AghanimLabMatchDifficultyEnum
    eliteDeathCount: Int
    eliteMatchCount: Int
    elitePickCount: Int
    eliteWinCount: Int
    encounterId: AghanimLabDepthListEncounterEnum
    matchCount: Int
    pickCount: Int
    winCount: Int
}

type AssistDetailType {
    attacker: Short
    gold: Int
    positionX: Int
    positionY: Int
    subTime: Int
    target: Short
    time: Int!
    xp: Int
}

type BattlepassPredictionHeroType {
    assistAvg: Float
    deathAvg: Float
    experiencePerMinuteAvg: Float
    hero: HeroType
    heroId: Short
    killAvg: Float
    lastHitAvg: Float
    matchCount: Int
    matchCountBanned: Int
    mostAssists: Int
    mostDeaths: Int
    mostKills: Int
    mostLastHits: Int
    winRate: Float
}

type BattlepassPredictionIdValueType {
    id: Long
    matchCount: Int
}

type BattlepassPredictionPlayerType {
    assistAvg: Float
    deathAvg: Float
    goldPerMinuteAvg: Int
    heroCount: Int
    killAvg: Float
    lastHitAvg: Float
    matchCount: Int
    mostAssists: Int
    mostGoldPerMinute: Int
    mostKills: Int
    mostLastHits: Int
    steamAccount: SteamAccountType
    steamAccountId: Int
}

type BattlepassPredictionTeamType {
    gameSecondsAvg: Float
    heroCount: Int
    killAvg: Float
    leastDeaths: Float
    longestGameSeconds: Int
    matchCount: Int
    mostAssists: Float
    mostKills: Float
    shortestGameSeconds: Int
    team: TeamType
    teamId: Int
}

type BattlepassPredictionTournamentType {
    heroesBanned: [BattlepassPredictionIdValueType]
    heroesPicked: [BattlepassPredictionIdValueType]
    longestGame: [BattlepassPredictionIdValueType]
    soloAssists: [BattlepassPredictionIdValueType]
    soloDeaths: [BattlepassPredictionIdValueType]
    soloGoldPerMinute: [BattlepassPredictionIdValueType]
    soloKills: [BattlepassPredictionIdValueType]
    totalKills: [BattlepassPredictionIdValueType]
}

type BlogType {
    bannerImageUrl: String!
    captainJackIdentityId: Guid
    data: String!
    id: Byte
    link: String!
    liveDateTime: DateTime
    title: String!
}

type BuyBackDetailType {
    cost: Int!
    deathTimeRemaining: Int!
    heroId: Short
    time: Int!
}

type CaptainJackIdentityApiApplicationType {
    apiKey: String
    captainJackIdentityId: Guid
    description: String
    discordAddress: String
    emailAddress: String
    isApproved: Boolean
    issuer: String
    matomoReferenceToken: String
    secretKey: String
    tokenType: StratzApiType
    websiteAddress: String
}

type CaptainJackIdentityPrivateProfileType {
    captainJackIdentityId: Guid
    dailyEmail: Boolean!
    email: String
    emailHour: Byte
    emailLevel: Byte
    emailValidationCode: String
    facebook: String
    feedLevel: Byte
    isAdmin: Boolean
    isEmailValidated: Boolean!
    languageId: Byte
    lastDailyEmail: Long
    lastLeagueDailyEmail: Long
    lastMonthlyEmail: Long
    lastProCircuitDailyEmail: Long
    lastReadFeedTime: Long
    lastSeen: Long
    lastTeamDailyEmail: Long
    lastWeeklyEmail: Long
    monthlyEmail: Boolean!
    name: String
    premiumEndDate: Long
    proCircuitEmailLevel: Byte
    proCircuitFeedLevel: Byte
    rosh(request: ROSHMatchesRequestType): [ROSHCaptainJackIdentityStatDifficultyType]
    themeType: Byte
    twitch: String
    twitter: String
    unsubscribeCode: String
    weeklyEmail: Boolean!
    youTube: String
}

type CaptainJackIdentityPublicProfileType {
    captainJackIdentityId: Guid
    facebook: String
    isAdmin: Boolean
    name: String
    twitch: String
    twitter: String
    youTube: String
}

type CaptainJackIdentityType {
    id: Guid
    profile: CaptainJackIdentityPublicProfileType
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type ClusterType {
    "ClusterId which determines in which region a match was played. One region has multiple clusters. When selecting your region in the Dota 2 client, a random cluster is provided to you for each match for load balancing purposes."
    id: Int
    "RegionId gives the exact geographical area where the match is played."
    regionId: Short
}

type ConstantQuery {
    "Find ability details."
    abilities(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The language id to include in this query, excluding all results that do not have this language."
        language: Language
    ): [AbilityType]
    "Find ability details by ability id. id is a required input field."
    ability(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The ability id to include in this query, excluding all results that do not have this ability."
        id: Int!,
        "The language id to include in this query, excluding all results that do not have this language."
        language: Language
    ): AbilityType
    casters: [SteamAccountType]
    "Provided directly from Dota 2 Region files, the cluster is the geographically breakdown of where the game is played."
    clusters: [ClusterType]
    "Find all abilities that are used in custom events. For example Aghnims Labyrinth."
    customAbilities(
        "The language id to include in this query, excluding all results that do not have this language."
        languageId: Language
    ): [AbilityCustomGameType]
    "Returns a list of game mode types which is directly supplied by Dota 2. Matches API call will have a input for this value."
    gameModes: [GameModeType]
    "Find game version details by game version id. id is a required input field."
    gameVersion(
        "The game version id to include in this query, excluding all results that do not have this game version."
        id: Short!
    ): GameVersionType
    "Find game version details."
    gameVersions: [GameVersionType]
    hero(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The hero id to include in this query, excluding all results that do not include this hero."
        id: Short!,
        "The language id to include in this query, excluding all results that do not have this language."
        language: Language
    ): HeroType
    heroes(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The language id to include in this query, excluding all results that do not have this language."
        language: Language
    ): [HeroType]
    "Find item details by item id. id is a required input field."
    item(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The item id to include in this query, excluding all results that do not have this item."
        id: Int!,
        "The language id to include in this query, excluding all results that do not have this language."
        language: Language
    ): ItemType
    "Find item details by item id. id is a required input field."
    items(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The language id to include in this query, excluding all results that do not have this language."
        language: Language
    ): [ItemType]
    "Returns a list of lobby types which are mirrored from the Dota 2 client."
    lobbyTypes: [LobbyTypeType]
    "Find all modifiers that are used in the game. If you find a bug on a modifier, let us know as we have to control this ourselves."
    modifiers(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [ModifierType]
    "Find npc details by npc id. id is a required input field."
    npc(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short,
        "The npc id to include in this query, excluding all results that do not have this npc."
        id: Short!
    ): NpcType
    "Find npc details."
    npcs(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short
    ): [NpcType]
    "Find all patch notes for each item and ability. These are found when you hover over each object in-game."
    patchNotes(
        "The language id to include in this query, excluding all results that do not have this language."
        languageId: Language
    ): [PatchNoteLanguageType]
    popularTeamIds: [TeamType]
    "Find all players who Valve qualifies as a Pro Player or Streamer."
    proSteamAccounts: [ProSteamAccountType]
    "Returns a list of region details and an Id for reference."
    regions: [RegionType]
    "List of all the roles types for heroes."
    roles: [RoleType]
    tiWinners: [SteamAccountType]
}

type DeathDetailType {
    assist: [Int]
    attacker: Short
    byAbility: Short
    byItem: Short
    goldFed: Int
    goldLost: Int
    hasHealAvailable: Boolean
    isAttemptTpOut: Boolean
    isBurst: Boolean
    isDieBack: Boolean
    isEngagedOnDeath: Boolean
    isFeed: Boolean
    isFromIllusion: Boolean
    isTracked: Boolean
    isWardWalkThrough: Boolean
    positionX: Int
    positionY: Int
    reliableGold: Int
    target: Short
    time: Int!
    timeDead: Int
    unreliableGold: Int
    xpFed: Int
}

type DireTideCustomGameHeroWinDayType {
    candyScored: Int!
    day: Long!
    heroId: Short!
    matchCount: Int!
    winCount: Int!
}

type DireTideCustomGameMatchType {
    candyLost: Short
    candyPickedUp: Short
    candyScored: Short
    clusterId: Short
    didRadiantWin: Boolean
    direCandyScored: Short
    durationSeconds: Short
    endDateTime: Long
    id: Long
    players(
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long
    ): [DireTideCustomGamePlayerType]
    radiantCandyScored: Short
    replaySalt: Long
    startDateTime: Long
}

type DireTideCustomGamePlayerType {
    assists: Byte
    backpack0Id: Short
    backpack1Id: Short
    backpack2Id: Short
    candyLost: Short
    candyPickedUp: Short
    candyScored: Short
    deaths: Byte
    goldPerMinute: Short
    goldSpent: Int
    hero: HeroType
    heroDamage: Int
    heroHealing: Int
    heroId: Short
    isVictory: Boolean!
    item0Id: Short
    item1Id: Short
    item2Id: Short
    item3Id: Short
    item4Id: Short
    item5Id: Short
    kills: Byte
    leaverStatus: Byte
    level: Byte
    matchId: Long
    networth: Int
    "The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id)."
    neutral0Id: Short
    numLastHits: Short
    partyId: Byte
    playerSlot: Byte
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type DotaMutation {
    admin: AdminMutation
    retryMatchDownload(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!
    ): Boolean
    rosh: ROSHMutation
    user: DotaUserMutation
    yogurt: YogurtMutation
}

type DotaNextQuery {
    "Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users."
    ally(
        "A steam account id found on your team to include in this query, excluding all results that do not include this steam account id found on your team."
        matchSteamAccountId: Long!,
        "An array of steam account ids to limit the query to only return matches with these steam account ids."
        steamAccountIds: [Long]!
    ): [DotaNextWithAllyType]
    "Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users."
    enemy(
        "A steam account id found on your team to include in this query, excluding all results that do not include this steam account id found on your team."
        matchSteamAccountId: Long!,
        "An array of steam account ids to limit the query to only return matches with these steam account ids."
        steamAccountIds: [Long]!
    ): [DotaNextWithAllyType]
    "Used by Overwolf application DotaNext (previously called DotaPlus) to provide data to its users."
    playerHero(
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: Byte!,
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short,
        "An array of item ids to include in this query, excluding all results that do not include one of these item ids."
        limitByItemIds: Int!,
        "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
        lobbyTypeIds: Byte!,
        "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
        startDateTime: Long!,
        "An array of steam account ids to limit the query to only return matches with these steam account ids."
        steamAccountIds: Long!
    ): [[MatchPlayerItemPurchaseEventType]]
}

type DotaNextWithAllyType {
    lifetimeMatchCount: Int
    lifetimeWinMatchCount: Int
    steamAccountId: Long
}

type DotaPlusWeekType {
    active: Int
    expired: Int
    week: Int
}

type DotaQuery {
    "Queries used to query constants in Dota."
    constants: ConstantQuery
    "For getting access to one specific Guild which was used at the start of TI10 Compendium."
    guild(
        "A guild id to include in this query, excluding all results that do not have this guild id."
        id: Int!
    ): GuildType
    "Queries used to gain insights into hero data and statistics."
    heroStats: HeroStatsQuery
    "Queries used to get leaderboard information."
    leaderboard: LeaderboardQuery
    "Find league details by league Id. Id is a required field."
    league(
        "A league id to include in this query, excluding all results that do not have this league id."
        id: Int!
    ): LeagueType
    "Find league details by searching for leagues using a LeagueRequest."
    leagues(request: LeagueRequestType!): [LeagueType]
    "Queries used to find live match data."
    live: LiveQuery
    "Find match details by the match id. id is a required input field."
    match(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        id: Long!
    ): MatchType
    "Find match details for each match id. ids is a required input field."
    matches(
        "An array of Dota match ids to include in this query."
        ids: [Long]!
    ): [MatchType]
    "Find player details by steam account id. id is a required input field."
    player(
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long!
    ): PlayerType
    "Find player details for each steam account id. ids is a required input field."
    players(
        "An array of steam account ids to limit the query to only return matches with these steam account ids."
        steamAccountIds: [Long]!
    ): [PlayerType]
    "Queries used to populate Stratz Plus."
    plus: PlusQuery
    "Stratz specific queries."
    stratz: StratzQuery
    "Find player details for each steam account id. ids is a required input field."
    team(
        "A team id to include in this query, excluding all results that do not have this team id."
        teamId: Int!
    ): TeamType
    "Results in a list of team objects that contain data about them and their players."
    teams(
        "A team id to include in this query, excluding all results that do not have this team id."
        teamIds: [Int]!
    ): [TeamType]
    "Queries used by 3rd party applications."
    vendor: VendorQuery
    "Queries used for Stratz Yogurt - users won't be able to access these calls until they have access to the app."
    yogurt: YogurtQuery
}

type DotaSubscription {
    feedLive: LiveEventType
    matchCount: TotalMatchCountType
    matchLive(matchId: Long!): MatchLiveType
    matchLiveLeague(leagueId: Int!): MatchLiveType
    playerCount: TotalPlayerCountType
}

type DotaUserMutation {
    applyStratzApiKey(
        description: String!,
        "A users Discord full Identity name."
        discordAddress: String!,
        "The desired email address of the match replay upload team. Cannot be blank or whitespace."
        emailAddress: String!,
        "There are two type of API Tokens, Data Collector and MultiKey"
        tokenType: StratzApiType!,
        "A user website where the data can be seen."
        websiteAddress: String!
    ): Boolean
    "If a user moves from annoymous to public, this will turn it on instantly for them."
    checkPublicDotaAccount: Boolean
    "Update your user to (un)follow a specific LeagueId"
    followLeague(
        "A league id to include in this query, excluding all results that do not have this league id."
        leagueId: Int!
    ): Boolean
    "Update your user to (un)follow a specific SteamAccountId"
    followPlayer(
        "The steam account of the person you wish to (un)follow."
        steamAccountId: Long!
    ): Boolean
    "Marks the user's LastReadFeedTime to the current time."
    readAllFeed: Boolean
    unfollowLeague(
        "A league id to include in this query, excluding all results that do not have this league id."
        leagueId: Int!
    ): Boolean
    "Update your user to (un)follow a specific SteamAccountId"
    unfollowPlayer(
        "The steam account of the person you wish to (un)follow."
        steamAccountId: Long!
    ): Boolean
    "Update your user to unsubscribe from Stratz emails."
    unsubscribeEmail(code: Guid!): Boolean
    "Updates every user you are following.  This should be handled with care, as this overrides all your predefinded user specific settings with these settings."
    updateAllFollowing(
        "The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings."
        request: UpdateFollowerRequestType!
    ): Boolean
    "Update your user to (un)follow a specific SteamAccountId"
    updateFollowing(
        "The steam account of the person you wish to (un)follow."
        followedSteamAccountId: Long!,
        "The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings."
        request: UpdateFollowerRequestType!
    ): Boolean
    "Gets more in-depth information about the person you are following.  This is a user specific request, and you can only edit yourself."
    updateFollowingFavorite(
        "The steam account of the person you wish to (un)follow."
        followedSteamAccountId: Long!,
        "Should the user become a favorite."
        isFavorite: Boolean!
    ): Boolean
    "Updates the logged in user information profile."
    updateProfile(
        "The updated returned object from /user. Only updates ThemeType, LanguageId, Email and Feed/Email Settings."
        request: CaptainJackIdentityProfileUpdateRequestType!
    ): Boolean
    "Validates a user email address if the password id is correct."
    validateEmail(
        "The password number that was sent via email."
        code: Guid!
    ): Boolean
}

type ExperienceDetailType {
    amount: Int!
    positionX: Int
    positionY: Int
    reason: XpReason
    time: Int!
}

type FeatType {
    hero: HeroType
    heroId: Int
    match: MatchType
    matchId: Long
    type: Feat
    value: Int
}

type FeedResponseType {
    attackAnimationPoint: DateTime
    count: Int
    data: [FeedType]
}

type FeedType {
    date: Long
    didWin: Boolean
    heroId: Int!
    league: LeagueType
    matchId: Long
    steamAccount: SteamAccountType
    targetSteamAccountId: Long
    type: Byte
    value: Int!
}

type FollowerType {
    captainJackIdentity: CaptainJackIdentityType
    captainJackIdentityId: Guid
    dailyEmail: Boolean
    didManualUpdate: Boolean!
    emailLevel: Byte
    feedLevel: Byte
    isFavorite: Boolean
    lastEmail: Long
    monthlyEmail: Boolean
    steamAccount: SteamAccountType
    steamAccountId: Long
    weeklyEmail: Boolean
}

type GameModeType {
    id: Short
    name: String
}

type GameVersionType {
    asOfDateTime: Long
    id: Short
    name: String
}

type GoldDetailType {
    amount: Int!
    isValidForStats: Boolean
    npcId: Int
    reason: GoldReason
    time: Int!
}

type GuildMemberType {
    guild: GuildType
    guildId: Int
    imp: Int
    joinDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Int
    winCount: Int
}

type GuildType {
    createdDateTime: Long
    currentPercentile: Byte
    description: String
    flags: Int
    id: Int
    language: Byte
    lastUpdateDateTime: Long
    logo: String
    matches(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [MatchType]
    memberCount: Byte
    members: [GuildMemberType]
    motd: String
    name: String
    pastWeeklyPercentile: Byte
    pastWeeklyRank: Int
    pattern: Byte
    points: Int
    primaryColor: Byte
    rank: Byte
    region: Byte
    requiredRank: Byte
    secondaryColor: Byte
    tag: String
    totalBattlePassLevels: Int
}

type HealDetailType {
    attacker: Short
    byAbility: Short
    byItem: Short
    target: Short
    time: Int!
    value: Int
}

type HeroAbilityMaxType {
    abilityId: Int
    bracketBasicIds: RankBracketBasicEnum
    heroId: Int!
    level: Int
    matchCount: Long
    position: MatchPlayerPositionType
    week: Int!
    winCount: Long
}

type HeroAbilityMinType {
    abilityId: Int
    bracketBasicIds: RankBracketBasicEnum
    heroId: Int!
    level: Int
    matchCount: Long
    position: MatchPlayerPositionType
    week: Int!
    winCount: Long
}

type HeroAbilityTalentType {
    abilityId: Int!
    bracketBasicIds: RankBracketBasicEnum
    heroId: Int!
    matchCount: Long!
    position: MatchPlayerPositionType
    time: Long
    timeAverage: Decimal
    week: Int!
    winCount: Long!
    winsAverage: Decimal
}

type HeroAbilityType {
    ability: AbilityType
    abilityId: Short!
    gameVersionId: Short!
    slot: Byte!
}

type HeroBanType {
    bracketBasicIds: RankBracketBasicEnum
    day: Int
    heroId: Short
    matchCount: Long
    winCount: Long
}

type HeroDamageDetailType {
    attacker: Short
    byAbility: Short
    byItem: Short
    damageType: Damage
    fromIllusion: Boolean
    fromNpc: Short
    isPhysicalAttack: Boolean
    isSourceMainHero: Boolean
    isTargetMainHero: Boolean
    target: Short
    time: Int!
    toIllusion: Boolean
    toNpc: Short
    value: Int!
}

type HeroDotaPlusLeaderboardRankTopType {
    createdDateTime: Long
    heroId: Short
    level: Byte
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type HeroDotaPlusLeaderboardRankType {
    createdDateTime: Long
    heroId: Short
    level: Byte
    steamAccount: SteamAccountType
    steamAccountId: Long
    totalActions: Long
}

type HeroDryadType {
    heroId: Short
    matchCountVs: Long
    matchCountWith: Long
    vs: [HeroStatsHeroDryadType]
    with: [HeroStatsHeroDryadType]
}

type HeroGuideListType {
    "Guides are auto-generated of games that are successful in a game."
    guides(
        "The item id to include in this query, excluding all results that do not have this item."
        itemId: Short,
        "The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id)."
        neutralItemId: Short,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroGuideType]
    heroId: Short
    matchCount: Int
}

type HeroGuideType {
    createdDateTime: Long
    heroId: Short
    itemIds: [Short]
    match: MatchType
    matchId: Long
    matchPlayer: MatchPlayerType
    neutralItemIds: [Short]
    steamAccountId: Long
}

type HeroItemBootPurchaseType {
    activationTime: Long
    activations: Long
    activationsAverage: Decimal
    activationsTimeAverage: Decimal
    assists: Long
    assistsAverage: Decimal
    bracketBasicIds: RankBracketBasicEnum
    deaths: Long
    deathsAverage: Decimal
    goldEarned: Long
    goldEarnedAverage: Decimal
    heroId: Int!
    instance: Int!
    itemId: Int!
    kills: Long
    killsAverage: Decimal
    matchCount: Long
    position: MatchPlayerPositionType
    time: Long
    timeAverage: Decimal
    week: Int!
    winAverage: Decimal
    winCount: Long
    xp: Long
    xpAverage: Decimal
}

type HeroItemPurchaseType {
    bracketBasicIds: RankBracketBasicEnum
    heroId: Int!
    instance: Int!
    itemId: Int!
    matchCount: Long
    position: MatchPlayerPositionType
    time: Long
    week: Int!
    winCount: Long
    winsAverage: Decimal
}

type HeroItemStartingPurchaseType {
    bracketBasicIds: RankBracketBasicEnum
    heroId: Int!
    instance: Int!
    itemId: Int!
    matchCount: Long
    position: MatchPlayerPositionType
    wasGiven: Boolean!
    week: Int!
    winCount: Long
    winsAverage: Decimal
}

type HeroLaneOutcomeType {
    bracketBasicIds: RankBracketBasicEnum
    drawCount: Long
    heroId1: Int!
    heroId2: Short!
    lossCount: Long
    matchCount: Long
    position: MatchPlayerPositionType
    stompLossCount: Long
    stompWinCount: Long
    week: Int!
    winCount: Long
}

type HeroLanguageType {
    displayName: String
    hype: String
    lore: String
}

type HeroMatchupType {
    advantage: [HeroDryadType]
    disadvantage: [HeroDryadType]
}

type HeroNeutralItemType {
    bracketBasicIds: RankBracketBasicEnum
    equippedMatchCount: Long
    equippedMatchWinCount: Long
    heroId: Int!
    item: ItemType
    itemId: Int
    matchCount: Long
    position: MatchPlayerPositionType
    week: Int!
    winCount: Long
}

type HeroPositionTimeDetailType {
    abilityCasts: Decimal
    ancients: Decimal
    apm: Decimal
    assists: Decimal
    attackCount: Decimal
    attackDamage: Decimal
    bracketBasicIds: RankBracketBasicEnum
    buybackCount: Decimal
    campsStacked: Decimal
    castDamage: Decimal
    casts: Decimal
    comeBackLost: Decimal
    comeBackWon: Decimal
    courierKills: Decimal
    cs: Decimal
    damage: Decimal
    damageReceived: Decimal
    deaths: Decimal
    disableCount: Decimal
    disableDuration: Decimal
    dn: Decimal
    godLike: Decimal
    goldFed: Decimal
    goldLost: Decimal
    goldPerMinute: Decimal
    healingAllies: Decimal
    healingItemAllies: Decimal
    healingItemSelf: Decimal
    healingSelf: Decimal
    heroDamage: Decimal
    heroId: Short!
    invisibleCount: Decimal
    kDAAverage: Decimal
    killContributionAverage: Decimal
    kills: Decimal
    level: Decimal
    magicalDamage: Decimal
    magicalDamageReceived: Decimal
    magicalItemDamage: Decimal
    matchCount: Long
    mvp: Decimal
    networth: Decimal
    neutrals: Decimal
    physicalDamage: Decimal
    physicalDamageReceived: Decimal
    physicalItemDamage: Decimal
    position: MatchPlayerPositionType
    pureDamage: Decimal
    pureDamageReceived: Decimal
    purgeModifiers: Decimal
    rampage: Decimal
    remainingMatchCount: Long
    runeBounty: Decimal
    runePower: Decimal
    slowCount: Decimal
    slowDuration: Decimal
    stompLost: Decimal
    stompWon: Decimal
    stunCount: Decimal
    stunDuration: Decimal
    supportGold: Decimal
    teamKills: Decimal
    time: Int!
    topCore: Decimal
    topSupport: Decimal
    towerDamage: Decimal
    tripleKill: Decimal
    ultraKill: Decimal
    weakenCount: Decimal
    weakenDuration: Decimal
    week: Int!
    winCount: Long
    xp: Decimal
    xpFed: Decimal
}

type HeroRampageObjectType {
    heroIds: [Short]
    match: MatchType
    matchId: Long
    steamAccount: SteamAccountType
    steamAccountId: Long
    time: Short!
}

type HeroRoleType {
    level: Short
    roleId: HeroRoleEnum
}

type HeroStatType {
    agilityBase: Float
    agilityGain: Float
    attackAcquisitionRange: Float
    attackAnimationPoint: Float
    attackRange: Float
    attackRate: Float
    attackType: String
    cMEnabled: Boolean
    complexity: Byte
    enabled: Boolean
    heroUnlockOrder: Float
    hpBarOffset: Float
    hpRegen: Float
    intelligenceBase: Float
    intelligenceGain: Float
    moveSpeed: Float
    moveTurnRate: Float
    mpRegen: Float
    newPlayerEnabled: Boolean
    primaryAttribute: String
    primaryAttributeEnum: HeroPrimaryAttributeType
    startingArmor: Float
    startingDamageMax: Float
    startingDamageMin: Float
    startingMagicArmor: Float
    strengthBase: Float
    strengthGain: Float
    team: Boolean
    visionDaytimeRange: Float
    visionNighttimeRange: Float
}

type HeroStatsHeroDryadType {
    assists: Long
    bracketBasicIds: RankBracketBasicEnum
    cs: Long
    deaths: Long
    dn: Long
    duration: Long
    firstBloodTime: Long
    goldEarned: Long
    heroDamage: Long
    heroHealing: Long
    heroId1: Short
    heroId2: Short
    kills: Long
    level: Long
    matchCount: Long
    networth: Long
    synergy: Decimal
    towerDamage: Long
    week: Int
    winCount: Long
    winRateHeroId1: Decimal
    winRateHeroId2: Decimal
    winsAverage: Decimal
    xp: Long
}

type HeroStatsQuery {
    "This helps determine at what level you first level a skill. (Level 1)"
    abilityMaxLevel(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroAbilityMaxType]
    "This helps determine at what level do you max a skill."
    abilityMinLevel(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroAbilityMinType]
    "This data for each day where a Hero is actually banned. This does not include data in which a hero was nominated for a ban but didn't actual get banned. Only data where a player actually requests a ban and its banned is shown."
    banDay(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The day to include in this query, excluding all results that do not include this day. The value is an epoc TimeStamp of the day of data you want. Leaving null gives the current day."
        day: Int,
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupByDay: Boolean,
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupByRank: Boolean,
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroBanType]
    guide(
        "The hero id to include in this query, excluding all results that do not include this hero."
        againstHeroId: Short,
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short,
        "Determines that the query require the results come with a player that is qualified as a Pro."
        isPro: Boolean,
        "The item id to include in this query, excluding all results that do not have this item."
        itemId: Short,
        "The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id)."
        neutralItemId: Short,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionId: MatchPlayerPositionType,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int,
        "The hero id to include in this query, excluding all results that do not include this hero."
        withHeroId: Short
    ): [HeroGuideListType]
    "This is used on the Hero page to show the comparison of skill with the selected hero with other heroes.  It includes our Synergy and our Advantage formulas to ensure that a hero with a high win rate isn't simply just on the top of all the fields."
    heroVsHeroMatchup(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "Minimum amount of MatchCount required for a Duo to qualify"
        matchLimit: Int,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int,
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): HeroMatchupType
    "The purchase Item Components for a Hero's Boots.  Tracks things like activations or uses throughout the game."
    itemBootPurchase(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroItemBootPurchaseType]
    "Returns the items purchased for the selected hero. Adjusting the time adjusts the purchase amount. Shows win rate by item timings."
    itemFullPurchase(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "Minimum amount of MatchCount required for a Duo to qualify"
        matchLimit: Int,
        "Integer in minutes which determines the start of the data. For example, 10 would result in every event before 10:00 mark in-game Maximum input value is 75."
        maxTime: Int,
        "Integer in minutes which determines the start of the data. For example, 10 would result in every event after 10:00 mark in-game. Minimum input value is 0."
        minTime: Int,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroItemPurchaseType]
    "The amount of times a Nutreal Item was found and won."
    itemNeutral(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroNeutralItemType]
    "This snapshots all items in the inventory of a hero at -00:30.   It tracks if an item was given or purchased."
    itemStartingPurchase(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroItemStartingPurchaseType]
    "Using out formula for determining the outcome of lane, the overall success of that hero in that role."
    laneOutcome(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "The lane outcomes are split into with heroes and against. Send false if you want lane matchups against the heroid. Send true if you want friendly."
        isWith: Boolean!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroLaneOutcomeType]
    "Returns back a list of the hero matchups, showing how that hero's win rate is affected with or against other heroes."
    matchUp(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short,
        "Minimum amount of MatchCount required for a Duo to qualify"
        matchLimit: Int,
        "Id representing how to order dryads and triads. Synergy is STRATZ formula to help determine the best outcome of wins and picks in one. Accepted Inputs : Synergy = 0, Pick = 1, Win = 2, Loss = 3, Disadvantage = 4, Advantage = 5"
        orderBy: Byte,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int,
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroDryadType]
    rampages(request: FilterHeroRampageType!): [HeroRampageObjectType]
    "Detailed output of data per minute for each hero."
    stats(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        groupByBracket: Boolean,
        groupByPosition: Boolean,
        groupByTime: Boolean,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: [Short],
        "Integer in minutes which determines the start of the data. For example, 10 would result in every event before 10:00 mark in-game Maximum input value is 75."
        maxTime: Int,
        "Integer in minutes which determines the start of the data. For example, 10 would result in every event after 10:00 mark in-game. Minimum input value is 0."
        minTime: Int,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroPositionTimeDetailType]
    "This is used on the Hero page to show the comparison of all Hero Talents with the selected hero."
    talent(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketBasicIds: [RankBracketBasicEnum],
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [HeroAbilityTalentType]
    "Returns the last 12 days by day showing the amount of matches and the amount of wins by hero id."
    winDay(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupBy: FilterHeroWinRequestGroupBy,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: [Short],
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroWinDayType]
    "Returns the data by game version showing the amount of matches and the amount of wins by hero id."
    winGameVersion(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupBy: FilterHeroWinRequestGroupBy,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: [Short],
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroWinGameVersionType]
    "Returns the last 12 hours by hour showing the amount of matches and the amount of wins by hero id."
    winHour(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupBy: FilterHeroWinRequestGroupBy,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: [Short],
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroWinHourType]
    "Returns the data by month showing the amount of matches and the amount of wins by hero id."
    winMonth(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupBy: FilterHeroWinRequestGroupBy,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: [Short],
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroWinMonthType]
    "Returns the last 12 weeks by week showing the amount of matches and the amount of wins by hero id."
    winWeek(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
        groupBy: FilterHeroWinRequestGroupBy,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: [Short],
        "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
        positionIds: [MatchPlayerPositionType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HeroWinWeekType]
}

type HeroTalentType {
    abilityId: Short
    slot: Byte
}

type HeroType {
    abilities: [HeroAbilityType]
    aliases: [String]
    displayName: String
    gameVersionId: Short
    id: Short
    language: HeroLanguageType
    name: String
    roles: [HeroRoleType]
    shortName: String
    stats: HeroStatType
    talents: [HeroTalentType]
}

type HeroWinDayType {
    day: Long!
    heroId: Short!
    matchCount: Int!
    winCount: Int!
}

type HeroWinGameVersionType {
    durationMinute: Byte!
    gameVersionId: Short!
    heroId: Short!
    matchCount: Int!
    winCount: Int!
}

type HeroWinHourType {
    heroId: Short!
    hour: Long!
    matchCount: Int!
    winCount: Int!
}

type HeroWinMonthType {
    durationMinute: Byte!
    heroId: Short!
    matchCount: Int!
    month: Long!
    winCount: Int!
}

type HeroWinWeekType {
    durationMinute: Byte!
    heroId: Short!
    matchCount: Int!
    week: Long!
    winCount: Int!
}

type HomepageHeroDryadType {
    bracketBasicIds: RankBracketBasicEnum
    comparisonHeroBaseWinRate: Decimal
    comparisonHeroId: Short
    mainHeroId: Short
    matchCount: Long
    synergy: Decimal
    winCount: Long
    winsAverage: Decimal
}

type HomepageHeroSynergyType {
    heroDryads: [HomepageHeroDryadType]
    mainHeroBaseWinRate: Decimal
    mainHeroId: Short
}

type ImpGeneratorMatchPlayerType {
    events: [[ImpGeneratorPlayerEventType]]
    impValues: [[Int]]
    winChance: [Float]
    winRateByPlayerMinuteValues: [[Float]]
}

type ImpGeneratorPlayerEventType {
    assists: UShort
    cs: UShort
    damageReceived: Int
    deaths: UShort
    dn: UShort
    healingAllies: Int
    kills: UShort
    level: Byte
    magicalDamage: Int
    neutrals: Int
    physicalDamage: Int
    pureDamage: Int
    runePower: Int
    time: Byte
}

type ImpGeneratorPlayerType {
    events: [ImpGeneratorPlayerEventType]
    impValues: [[Int]]
    winChance: [Float]
    winRateByPlayerMinuteValues: [[Float]]
}

type ImpQuery {
    "Returns details about all players in a specific match and details regarding Imp"
    matchGenerator(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!
    ): ImpGeneratorMatchPlayerType
    "Returns details about a specific player in a game with certains events."
    playerGenerator(request: ImpGeneratorRequestType!): ImpGeneratorPlayerType
}

type InventoryObjectType {
    charges: Int
    itemId: Short
    secondaryCharges: Int
}

type InventoryType {
    backPack0: InventoryObjectType
    backPack1: InventoryObjectType
    backPack2: InventoryObjectType
    item0: InventoryObjectType
    item1: InventoryObjectType
    item2: InventoryObjectType
    item3: InventoryObjectType
    item4: InventoryObjectType
    item5: InventoryObjectType
    neutral0: InventoryObjectType
    teleport0: InventoryObjectType
    time: Int!
}

type ItemAttributeType {
    name: String
    value: String
}

type ItemComponentType {
    componentId: Short
    index: Byte
}

type ItemLanguageType {
    attributes: [String]
    description: [String]
    displayName: String
    lore: [String]
    notes: [String]
}

type ItemPurchaseType {
    itemId: Short
    time: Int!
}

type ItemStatType {
    aliases: String
    behavior: Long
    castPoint: [Float]
    castRange: [Int]
    channelTime: [Float]
    cost: Int
    fightRecapLevel: Byte
    initialCharges: Short
    initialStock: Short
    initialStockTime: Short
    isAlertable: Boolean
    isDisplayCharges: Boolean
    isDroppable: Boolean
    isHideCharges: Boolean
    isPermanent: Boolean
    isPurchasable: Boolean
    isRecipe: Boolean
    isRequiresCharges: Boolean
    isSellable: Boolean
    isSideShop: Boolean
    isStackable: Boolean
    isSupport: Boolean
    isTempestDoubleClonable: Boolean
    itemResult: Short
    manaCost: [Float]
    needsComponents: Boolean
    neutralItemDropTime: Short
    neutralItemTier: NeutralItemTierEnum
    quality: String
    sharedCooldown: String
    shopTags: String
    stockMax: Short
    stockTime: Int
    unitTargetFlags: Long
    unitTargetTeam: Long
    unitTargetType: Long
    upgradeItem: Short
    upgradeRecipe: Short
}

type ItemType {
    attributes: [ItemAttributeType]
    components: [ItemComponentType]
    displayName: String
    id: Short
    image: String
    isSupportFullItem: Boolean
    language: ItemLanguageType
    name: String
    shortName: String
    stat: ItemStatType
}

type ItemUsedEventType {
    attacker: Short
    itemId: Short
    target: Short
    time: Int!
}

type KillDetailType {
    assist: [Int]
    attacker: Short
    byAbility: Short
    byItem: Short
    gold: Int
    isFromIllusion: Boolean
    isGank: Boolean
    isInvisible: Boolean
    isRuneEffected: Boolean
    isSmoke: Boolean
    isSolo: Boolean
    isTpRecently: Boolean
    positionX: Int
    positionY: Int
    target: Short
    time: Int!
    xp: Int
}

type LanguageType {
    displaLanguageNameyName: String
    id: Byte!
    languageCode: String
}

type LastHitDetailType {
    attacker: Short
    byAbility: Short
    byItem: Short
    gold: Int
    isAncient: Boolean
    isCreep: Boolean
    isFromIllusion: Boolean
    isNeutral: Boolean
    mapLocation: MapLocationEnums
    npcId: Short
    positionX: Int
    positionY: Int
    time: Int!
    xp: Int
}

type LeaderboardQuery {
    "Gets the current leaderboard for Battle Pass levels."
    battlePass(
        countryCode: String,
        "The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."
        eventId: Byte,
        levels: [Int]
    ): PlayerBattlePassResponseType
    "Gets the current leaderboard for Battle Pass levels."
    battlePassGroupBy(
        countryCode: String,
        "The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."
        eventId: Byte,
        "The Event Id Assigned by Valve.  22 is TI8, 25 is TI9."
        groupBy: PlayerBattlePassGroupByEnum!
    ): [PlayerBattlePassGroupByType]
    "Gets the current leaderboard for all coaches by level."
    coaching(levels: [Int]): PlayerCoachingLeaderboardResponseType
    "Gets the players of Dota which have DotaPlus and have a high level hero."
    dotaPlus(
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short,
        "Only returns players of this level."
        level: Byte,
        "Id representing how to order the dota plus leader board. Accepted values are Recent = 0 (Shows the most recent awards given) and Level = 1 (shows by the highest level first)"
        orderBy: FilterLeaderboardOrder,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): PlayerHeroDotaPlusLeaderboardRankResponseType
    "Gets the top player of DotaPlus order by Level and Time Achived."
    dotaPlusTopLevels: [HeroDotaPlusLeaderboardRankTopType]
    "Show amount of active and expired DotaPlus users by Week"
    dotaPlusWeek: [DotaPlusWeekType]
    "Gets the current leaderboard for all guilds by points."
    guild(request: FilterLeaderboardGuildRequestType): [GuildType]
    "Gets the current leaderboard for all players by a specific Hero, order by IMP."
    hero(request: FilterLeaderboardHeroRequestType): [PlayerLeaderBoardByHeroType]
    "Returns the list of the current season leaderboard."
    season(request: FilterSeasonLeaderboardRequestType): SteamAccountSeasonActiveLeaderboardType
}

type LeagueBattlePassType {
    average: Int
    count: Int
}

type LeagueDpcPositionStatObjectType {
    avgAssists: Float
    avgDeaths: Float
    avgKills: Float
    matchCount: Int
    position: MatchPlayerPositionType
}

type LeagueMetaDetailType {
    banCount: Int
    banRate: Decimal
    heroId: Short
    lossCount: Int
    pickCount: Int
    pickRate: Decimal
    winCount: Int
    winRate: Decimal
}

type LeagueMetaType {
    bestRecord: LeagueMetaDetailType
    league: LeagueType
    leagueId: Int
    missingMatchCount: Int
    mostBanned: LeagueMetaDetailType
    mostPicked: LeagueMetaDetailType
    totalMatchCount: Int
}

type LeagueNodeGroupType {
    advancingNodeGroupId: Short
    advancingTeamCount: Byte
    defaultNodeType: LeagueNodeDefaultGroupEnum
    eliminationDPCPoints: Int
    endDate: Long
    id: Short
    isCompleted: Boolean
    isFinalGroup: Boolean
    isTieBreaker: Boolean
    maxRounds: Byte
    name: String
    nodeGroupType: LeagueNodeGroupTypeEnum
    nodes: [LeagueNodeType]
    parentNodeGroupId: Short
    phase: Byte
    region: Byte
    round: Byte
    secondaryAdvancingNodeGroupId: Short
    secondaryAdvancingTeamCount: Byte
    startDate: Long
    teamCount: Byte
    tertiaryAdvancingNodeGroupId: Short
    tertiaryAdvancingTeamCount: Byte
}

type LeagueNodeType {
    actualTime: Long
    hasStarted: Boolean
    id: Short
    isCompleted: Boolean
    losingNodeId: Short
    matches: [MatchType]
    name: String
    nodeGroupId: Short
    nodeType: LeagueNodeDefaultGroupEnum
    scheduledTime: Long
    seriesId: Long
    streamIds: [Int]
    streams: [LeagueStreamType]
    teamOne: TeamType
    teamOneId: Int
    teamOneWins: Byte
    teamTwo: TeamType
    teamTwoId: Int
    teamTwoWins: Byte
    winningNodeId: Short
}

type LeaguePrizePoolPercentageType {
    index: Byte
    leagueId: Int
    percentage: Int
}

type LeagueRegisteredPlayerType {
    league: LeagueType
    leagueId: Int
    radiantTeam: TeamType
    steamAccount: SteamAccountType
    steamAccountId: Long
    teamId: Int
}

type LeagueStatType {
    averageMatchDurationSeconds: Int
    matchCount: Int
    radiantWinMatchCount: Int
}

type LeagueStreamType {
    broadcastProvider: Byte
    id: Int
    languageId: Language
    name: String
    streamUrl: String
    vodUrl: String
}

type LeagueTableHeroLanesObjectType {
    id: Byte
    matchCount: Int!
    matchWins: Int!
}

type LeagueTableHeroOverviewType {
    banCount: Int!
    banPhaseOne: Int!
    banPhaseThree: Int!
    banPhaseTwo: Int!
    matchCount: Int!
    matchWins: Int!
    pickPhaseOne: Int!
    pickPhaseThree: Int!
    pickPhaseTwo: Int!
}

type LeagueTableHeroStatsType {
    assists: Float!
    cs: Float!
    deaths: Float!
    gpm: Float!
    heal: Float!
    heroDamage: Float!
    killContribution: Float!
    kills: Float!
    towerDamage: Float!
    xpm: Float!
}

type LeagueTableHeroType {
    heroId: Short
    heroes: [LeagueTableHeroStatsType]
    lanes: [LeagueTableHeroLanesObjectType]
    overview: LeagueTableHeroOverviewType
    stats: LeagueTableHeroStatsType
}

type LeagueTablePlayerHeroesObjectType {
    heroId: Int!
    imp: Int!
    matchCount: Int!
    matchWins: Int!
}

type LeagueTablePlayerLanesObjectType {
    id: Byte
    matchCount: Int!
    matchWins: Int!
}

type LeagueTablePlayerOverviewType {
    earnings: Float
    imp: Int!
    matchCount: Int!
    matchWins: Int!
    points: Float
    seriesCount: Int!
    seriesWins: Int!
}

type LeagueTablePlayerStatsType {
    assists: Float!
    cs: Float!
    deaths: Float!
    gpm: Float!
    heal: Float!
    heroDamage: Float!
    killContribution: Float!
    kills: Float!
    towerDamage: Float!
    xpm: Float!
}

type LeagueTablePlayerType {
    heroes: [LeagueTablePlayerHeroesObjectType]
    lanes: [LeagueTablePlayerLanesObjectType]
    overview: LeagueTablePlayerOverviewType
    stats: LeagueTablePlayerStatsType
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type LeagueTableTeamHeroesObjectType {
    banCount: Int
    heroId: Int!
    imp: Decimal
    matchCount: Int!
    matchWins: Int!
}

type LeagueTableTeamLanesObjectType {
    id: Byte
    matchCount: Int!
    matchWins: Int!
}

type LeagueTableTeamOverviewType {
    earnings: Float
    matchCount: Int!
    matchWins: Int!
    points: Float
    seriesCount: Int!
    seriesDraws: Int!
    seriesWins: Int!
    tmp: Float
}

type LeagueTableTeamStatsType {
    assists: Float!
    cs: Float!
    deaths: Float!
    duration: Float!
    gpm: Float!
    heal: Float!
    heroDamage: Float!
    kills: Float!
    towerDamage: Float!
    xpm: Float!
}

type LeagueTableTeamType {
    heroes: [LeagueTableTeamHeroesObjectType]
    lanes: [LeagueTableTeamLanesObjectType]
    members: [LeagueRegisteredPlayerType]
    overview: LeagueTableTeamOverviewType
    stats: LeagueTableTeamStatsType
    team: TeamType
    teamId: Int
}

type LeagueTableType {
    leagueId: Int!
    tableHeroes: [LeagueTableHeroType]
    tablePlayers: [LeagueTablePlayerType]
    tableTeams: [LeagueTableTeamType]
}

type LeagueType {
    banner: String
    basePrizePool: Int
    battlePass: LeagueBattlePassType
    country: String
    description: String
    displayName: String
    endDateTime: Long
    freeToSpectate: Boolean
    hasLiveMatches: Boolean
    id: Int
    imageUri: String
    isFollowed: Boolean
    lastMatchDate: Long
    liveMatches: [MatchLiveType]
    matches(
        "The request object used to filter matches returned based on input criteria."
        request: LeagueMatchesRequestType!
    ): [MatchType]
    "Find match details by steam account id. The return is modified to group the data by the GroupBy parameter."
    matchesGroupBy(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerMatchesGroupByRequestType!
    ): [MatchGroupByType]
    name: String
    nodeGroups: [LeagueNodeGroupType]
    private: Boolean
    prizePool: Int
    prizePoolPercentages: [LeaguePrizePoolPercentageType]
    region: LeagueRegion
    series(
        "When searching for league matches, an array of the stage type ids the match must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions Qualifers = 3, Group Stage = 4, Main Event = 5"
        leagueStageTypeIds: [LeagueStage],
        "A series id to include in this query, excluding all results that do not have this series id."
        seriesId: Int,
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int,
        "A team id to include in this query, excluding all results that do not have this team id."
        teamId: Int
    ): [SeriesType]
    standings: [TeamPrizeType]
    startDateTime: Long
    stats(
        "When searching for league matches, an array of the stage type ids the match must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions Qualifers = 3, Group Stage = 4, Main Event = 5"
        leagueStageTypeIds: [LeagueStage]
    ): LeagueStatType
    stopSalesTime: DateTime
    streams: [LeagueStreamType]
    tables(
        "To modify the values of Kills, Deaths, Assists, etc.  Accepted inputs are Average (default), Highest, Lowest, Median."
        calculateTypeId: TableCalculateEnum,
        "When searching for league matches, an array of the stage type ids the match must be in. Stages: Open Qualifers = 1, Closed Qualifers = 2, Champions Qualifers = 3, Group Stage = 4, Main Event = 5"
        leagueStageTypeIds: [LeagueStage]
    ): LeagueTableType
    tier: LeagueTier
    tournamentUrl: String
    venue: String
}

type LiveEventMatchDireTideStompType {
    match: DireTideCustomGameMatchType
}

type LiveEventPlayerDireTideCandyScoredType {
    candyScored: Short
    heroId: Short
    match: DireTideCustomGameMatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroAssistsType {
    assistCount: Byte
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroBuildingDamageType {
    buildingDamage: Int
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroDewardType {
    dewardCount: Byte
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroDotaPlusLevelType {
    heroId: Short
    level: Byte
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroExpPerMinuteType {
    expPerMinute: Short
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroGoldPerMinuteType {
    goldPerMinute: Short
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroHealingType {
    healingAmount: Int
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroHeroDamageType {
    heroDamage: Int
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroHighImpType {
    heroId: Short
    imp: Byte
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroItemPurchaseType {
    heroId: Short
    itemCount: Byte
    itemId: Short
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroKillsType {
    heroId: Short
    killCount: Byte
    match: MatchType
    steamAccount: SteamAccountType
}

type LiveEventPlayerHeroWinStreakType {
    heroId: Short
    match: MatchType
    steamAccount: SteamAccountType
    winStreakCount: Byte
}

type LiveEventPlayerRampageType {
    heroId: Short
    match: MatchType
    rampageCount: Byte
    steamAccount: SteamAccountType
}

type LiveEventPlayerRankUpType {
    match: MatchType
    rank: Byte
    steamAccount: SteamAccountType
}

type LiveEventPlayerWinStreakType {
    match: MatchType
    steamAccount: SteamAccountType
    winStreakCount: Byte
}

type LiveEventProPlayerLiveType {
    match: MatchLiveType
    steamAccounts: [SteamAccountType]
}

type LiveQuery {
    "Find a live match by match id. A live match is data where a match is on the Dota watch list and still active. All League games are also Live. id is a required input field."
    match(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        id: Long!,
        "The amount in seconds you wish to skip until you start getting MatchEvents or PlayerMatchEvents. When requesting reply data back, you may only want the updates from X second on. This will skip the first set of seconds and give everything after this time."
        skipPlaybackDuration: Int
    ): MatchLiveType
    "Find all live matches. A live match is data where a match is on the Dota watch list and still active. All League games are also Live."
    matches(request: MatchLiveRequestType): [MatchLiveType]
}

type LobbyTypeType {
    id: Int!
    name: String
}

type MatchGroupByAssistsType {
    assistCount: Long
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByAwardType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    award: MatchPlayerAward
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByClusterType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    cluster: Long
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByDateDayType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    dateDay: Long
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByDeathsType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    deathCount: Long
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByDurationMinutesType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    durationMinutes: Long
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByFactionType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isRadiant: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByGameModeType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    gameMode: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByGameVersionType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    gameVersion: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByGoldPerMinuteType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    goldPerMinute: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByHeroPerformanceType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    heroPeroformance: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByHeroType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    hero(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short!
    ): HeroType
    heroId: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsIntentionalFeedingType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isIntentionalFeeding: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsLeagueType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isLeague: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsLeaverType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isLeaver: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsPartyType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isParty: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsRandomType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isRandom: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsSeriesType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isSeries: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsStatsType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isStats: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByIsVictoryType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    isVictory: Boolean
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByKillsType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    killCount: Long
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByLaneType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lane: MatchLaneType
    lastMatchDateTime: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByLeagueIdType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    league: LeagueType
    leagueId: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByLevelType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    level: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByLobbyTypeType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    lobbyType: Long
    matchCount: Int
    winCount: Int
}

type MatchGroupByPositionType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    position: MatchPlayerPositionType
    winCount: Int
}

type MatchGroupByRegionType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    region: Long
    winCount: Int
}

type MatchGroupByRoamLaneType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    roamLane: MatchPlayerAward
    winCount: Int
}

type MatchGroupByRoleType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    role: MatchPlayerRoleType
    winCount: Int
}

type MatchGroupBySteamAccountIdAgainstTeamType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type MatchGroupBySteamAccountIdHeroIdAgainstTeamType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    hero(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short!
    ): HeroType
    heroId: Short
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type MatchGroupBySteamAccountIdHeroIdType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    hero(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short!
    ): HeroType
    heroId: Short
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type MatchGroupBySteamAccountIdHeroIdWithTeamType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    hero(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVersionId: Short!
    ): HeroType
    heroId: Short
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type MatchGroupBySteamAccountIdType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type MatchGroupBySteamAccountIdWithTeamType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type MatchGroupByTeamType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    team: TeamType
    teamId: Long
    winCount: Int
}

type MatchGroupByTotalKillsType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    totalKills: Long
    winCount: Int
}

type MatchLiveBuildingDetailType {
    indexId: Int
    isAlive: Boolean!
    isRadiant: Boolean
    npcId: Int
    positionX: Int
    positionY: Int
    time: Int!
    type: BuildingType
}

type MatchLiveInsightType {
    lastSeries: [SeriesType]
    teamOneLeagueMatchCount: Int!
    teamOneLeagueWinCount: Int!
    teamOneVsWinCount: Int!
    teamTwoLeagueMatchCount: Int!
    teamTwoLeagueWinCount: Int!
    teamTwoVsWinCount: Int!
}

type MatchLivePickBanType {
    adjustedWinRate: Float
    bannedHeroId: Short
    baseWinRate: Float
    durationValues: [Float]
    heroId: Short
    isPick: Boolean!
    isRadiant: Boolean
    letter: PlusLetterType
    order: Int
    position: MatchPlayerPositionType
    positionValues: [Float]
    winRateValues: [Float]
}

type MatchLivePlaybackDataType {
    buildingEvents: [MatchLiveBuildingDetailType]
    direScore: [MatchLiveTeamScoreDetailType]
    pickBans: [MatchLivePickBanType]
    radiantScore: [MatchLiveTeamScoreDetailType]
    roshanEvents: [MatchLiveRoshanDetailType]
}

type MatchLivePlayerAssistDetailType {
    positionX: Int!
    positionY: Int!
    time: Int!
}

type MatchLivePlayerDeathDetailType {
    positionX: Int!
    positionY: Int!
    time: Int!
}

type MatchLivePlayerDenyDetailType {
    positionX: Int!
    positionY: Int!
    time: Int!
}

type MatchLivePlayerExperienceDetailType {
    expPerMinute: Int!
    time: Int!
}

type MatchLivePlayerGoldDetailType {
    gold: Int!
    goldPerMinute: Int!
    networth: Int!
    networthDifference: Int!
    time: Int!
}

type MatchLivePlayerImpDetailType {
    imp: Short!
    time: Int!
}

type MatchLivePlayerInventoryDetailType {
    backpackId0: Short
    backpackId1: Short
    backpackId2: Short
    itemId0: Short
    itemId1: Short
    itemId2: Short
    itemId3: Short
    itemId4: Short
    itemId5: Short
    time: Int!
}

type MatchLivePlayerKillDetailType {
    positionX: Int!
    positionY: Int!
    time: Int!
}

type MatchLivePlayerLastHitDetailType {
    positionX: Int!
    positionY: Int!
    time: Int!
}

type MatchLivePlayerLevelDetailType {
    level: Int!
    time: Int!
}

type MatchLivePlayerPositionDetailType {
    time: Int!
    x: Int!
    y: Int!
}

type MatchLivePlayerType {
    backpackId0: Short
    backpackId1: Short
    backpackId2: Short
    baseWinRateValue: Float
    experiencePerMinute: UShort
    gameVersionId: Short
    gold: Int
    goldPerMinute: UShort
    goldSpent: Int
    hero: HeroType
    heroDamage: Int
    heroId: Short
    impPerMinute: [MatchLivePlayerImpDetailType]
    isRadiant: Boolean
    itemId0: Short
    itemId1: Short
    itemId2: Short
    itemId3: Short
    itemId4: Short
    itemId5: Short
    leaverStatus: Byte
    level: Byte
    matchId: Long
    name: String
    networth: Int
    numAssists: Byte
    numDeaths: Byte
    numDenies: UShort
    numKills: Byte
    numLastHits: UShort
    playbackData: MatchPlayerLivePlaybackDataType
    playerSlot: Byte
    position: MatchPlayerPositionType
    respawnTimer: Short
    steamAccount: SteamAccountType
    steamAccountId: Long
    towerDamage: Int
    ultimateCooldown: Short
    ultimateState: Short
}

type MatchLiveRoshanDetailType {
    isAlive: Boolean
    respawnTimer: Int
    time: Int
}

type MatchLiveTeamScoreDetailType {
    score: Short
    time: Int
}

type MatchLiveType {
    averageRank: Int
    buildingState: Long
    completed: Boolean
    createdDateTime: Long
    delay: Short
    direScore: Byte
    direTeam: TeamType
    direTeamId: Int
    durationValues: [Float]
    gameMinute: Short
    gameMode: GameModeEnumType
    gameState: MatchLiveGameState
    gameTime: Int
    insight: MatchLiveInsightType
    isParsing: Boolean
    isUpdating: Boolean
    league: LeagueType
    leagueId: Int
    liveWinRateValues: [MatchLiveWinRateDetailType]
    lobbyId: Long
    lobbyType: LobbyTypeEnum
    matchId: Long
    modifiedDateTime: Long
    numHumanPlayers: Byte
    parseBeginGameTime: Int
    playbackData: MatchLivePlaybackDataType
    players: [MatchLivePlayerType]
    radiantLead: Int
    radiantScore: Byte
    radiantTeam: TeamType
    radiantTeamId: Int
    serverSteamId: Long
    spectators: Int
    winRateValues: [Float]
}

type MatchLiveWinRateDetailType {
    time: Int!
    winRate: Float!
}

type MatchPickBanGroupByType {
    banCount: Int
    heroId: Short
    matchCount: Int
    pickCount: Int
}

type MatchPlaybackDataBuildingEventType {
    didShrineActivate: Boolean
    hp: Int
    indexId: Int
    isRadiant: Boolean
    maxHp: Int
    npcId: Int
    positionX: Int
    positionY: Int
    time: Int!
    type: BuildingType
}

type MatchPlaybackDataCourierEventType {
    events: [MatchplaybackDataCourierEventObjectType]
    id: Int!
    isRadiant: Boolean
    ownerHero: Int
}

type MatchPlaybackDataRoshanEventType {
    createTime: Int
    hp: Int
    item0: Int
    item1: Int
    item2: Int
    item3: Int
    item4: Int
    item5: Int
    maxHp: Int
    time: Int!
    totalDamageTaken: Int
    x: Int
    y: Int
}

type MatchPlaybackDataRuneEventType {
    action: Int!
    indexId: Int!
    location: Int!
    positionX: Int!
    positionY: Int!
    rune: Int!
    time: Int!
}

type MatchPlaybackDataTowerDeathEventType {
    dire: Int!
    radiant: Int!
    time: Int!
}

type MatchPlaybackDataType {
    buildingEvents: [MatchPlaybackDataBuildingEventType]
    courierEvents: [MatchPlaybackDataCourierEventType]
    direCaptainSteamAccount: SteamAccountType
    direCaptainSteamAccountId: Long
    radiantCaptainSteamAccount: SteamAccountType
    radiantCaptainSteamAccountId: Long
    roshanEvents: [MatchPlaybackDataRoshanEventType]
    runeEvents: [MatchPlaybackDataRuneEventType]
    towerDeathEvents: [MatchPlaybackDataTowerDeathEventType]
    wardEvents: [MatchPlaybackDataWardEventType]
}

type MatchPlaybackDataWardEventType {
    action: SpawnActionType
    fromPlayer: Int
    indexId: Int!
    playerDestroyed: Int
    positionX: Int!
    positionY: Int!
    time: Int!
    wardType: WardType
}

type MatchPlayerAdditionalUnitType {
    backpack0Id: Short
    backpack1Id: Short
    backpack2Id: Short
    item0Id: Short
    item1Id: Short
    item2Id: Short
    item3Id: Short
    item4Id: Short
    item5Id: Short
    neutral0Id: Short
}

type MatchPlayerHeroDamageSourceAbilityReportObjectType {
    abilityId: Int!
    amount: Int!
    count: Int!
}

type MatchPlayerHeroDamageSourceItemReportObjectType {
    amount: Int!
    count: Int!
    itemId: Int!
}

type MatchPlayerHeroDamageTargetReportObjectType {
    amount: Int!
    target: Int!
}

type MatchPlayerHeroDamageTotalRecievedReportObjectType {
    disableCount: Int!
    disableDuration: Int!
    heal: Int!
    magicalDamage: Int!
    physicalDamage: Int!
    pureDamage: Int!
    slowCount: Int!
    slowDuration: Int!
    stunCount: Int!
    stunDuration: Int!
}

type MatchPlayerHeroDamageTotalReportObjectType {
    allyHeal: Int!
    disableCount: Int!
    disableDuration: Int!
    magicalDamage: Int!
    physicalDamage: Int!
    pureDamage: Int!
    selfHeal: Int!
    slowCount: Int!
    slowDuration: Int!
    stunCount: Int!
    stunDuration: Int!
}

type MatchPlayerInventoryObjectType {
    charges: Int
    itemId: Int!
    secondaryCharges: Int
}

type MatchPlayerInventoryType {
    backPack0: MatchPlayerInventoryObjectType
    backPack1: MatchPlayerInventoryObjectType
    backPack2: MatchPlayerInventoryObjectType
    item0: MatchPlayerInventoryObjectType
    item1: MatchPlayerInventoryObjectType
    item2: MatchPlayerInventoryObjectType
    item3: MatchPlayerInventoryObjectType
    item4: MatchPlayerInventoryObjectType
    item5: MatchPlayerInventoryObjectType
    neutral0: MatchPlayerInventoryObjectType
}

type MatchPlayerItemPurchaseEventType {
    itemId: Int!
    time: Int!
}

type MatchPlayerLivePlaybackDataType {
    assistEvents: [MatchLivePlayerAssistDetailType]
    csEvents: [MatchLivePlayerLastHitDetailType]
    deathEvents: [MatchLivePlayerDeathDetailType]
    denyEvents: [MatchLivePlayerDenyDetailType]
    experienceEvents: [MatchLivePlayerExperienceDetailType]
    goldEvents: [MatchLivePlayerGoldDetailType]
    inventoryEvents: [MatchLivePlayerInventoryDetailType]
    killEvents: [MatchLivePlayerKillDetailType]
    levelEvents: [MatchLivePlayerLevelDetailType]
    positionEvents: [MatchLivePlayerPositionDetailType]
}

type MatchPlayerPlaybackDataType {
    abilityActiveLists: [AbilityActiveListType]
    abilityLearnEvents: [AbilityLearnEventsType]
    abilityUsedEvents: [AbilityUsedEventsType]
    assistEvents: [AssistDetailType]
    buyBackEvents: [BuyBackDetailType]
    csEvents: [LastHitDetailType]
    deathEvents: [DeathDetailType]
    experienceEvents: [ExperienceDetailType]
    goldEvents: [GoldDetailType]
    healEvents: [HealDetailType]
    heroDamageEvents: [HeroDamageDetailType]
    inventoryEvents: [InventoryType]
    itemUsedEvents: [ItemUsedEventType]
    killEvents: [KillDetailType]
    playerUpdateAttributeEvents: [PlayerUpdateAttributeDetailType]
    playerUpdateBattleEvents: [PlayerUpdateBattleDetailType]
    playerUpdateGoldEvents: [PlayerUpdateGoldDetailType]
    playerUpdateHealthEvents: [PlayerUpdateHealthDetailType]
    playerUpdateLevelEvents: [PlayerUpdateLevelDetailType]
    playerUpdatePositionEvents: [PlayerUpdatePositionDetailType]
    purchaseEvents: [ItemPurchaseType]
    runeEvents: [PlayerRuneDetailType]
    spiritBearInventoryEvents: [SpiritBearInventoryType]
    streakEvents: [StreakEventType]
    towerDamageEvents: [TowerDamageDetailType]
}

type MatchPlayerSpectatorType {
    isRadiantCoach: Boolean
    isVictory: Boolean
    steamId: Long
}

type MatchPlayerSpiritBearInventoryType {
    backPack0Id: Int
    backPack1Id: Int
    backPack2Id: Int
    item0Id: Int
    item1Id: Int
    item2Id: Int
    item3Id: Int
    item4Id: Int
    item5Id: Int
    neutral0Id: Int
}

type MatchPlayerStatsAbilityCastObjectType {
    count: Int!
    damage: Int!
    duration: Int
    target: Int!
}

type MatchPlayerStatsAbilityCastReportType {
    abilityId: Int!
    count: Int!
    targets: [MatchPlayerStatsAbilityCastObjectType]
}

type MatchPlayerStatsActionReportType {
    attackPosition: Int!
    attackTarget: Int!
    castNoTarget: Int!
    castPosition: Int!
    castTarget: Int!
    glyphCast: Int!
    heldPosition: Int!
    moveToPosition: Int!
    moveToTarget: Int!
    pingUsed: Int!
    scanUsed: Int!
}

type MatchPlayerStatsAllTalkEventType {
    message: String
    pausedTick: Int!
    time: Int!
}

type MatchPlayerStatsAssistEventType {
    gold: Int
    positionX: Int
    positionY: Int
    target: Int
    time: Int!
    xp: Int
}

type MatchPlayerStatsBuffEventType {
    abilityId: Int
    itemId: Int
    stackCount: Int
    time: Int!
}

type MatchPlayerStatsChatWheelEventType {
    chatWheelId: Short
    time: Int!
}

type MatchPlayerStatsCourierKillEventType {
    positionX: Int
    positionY: Int
    time: Int!
}

type MatchPlayerStatsDeathEventType {
    assist: [Short!]
    attacker: Short
    byAbility: Int
    byItem: Int
    goldFed: Int
    goldLost: Int
    hasHealAvailable: Boolean
    isAttemptTpOut: Boolean
    isBurst: Boolean
    isDieBack: Boolean
    isEngagedOnDeath: Boolean
    isTracked: Boolean
    isWardWalkThrough: Boolean
    positionX: Int
    positionY: Int
    target: Int
    time: Int!
    timeDead: Int
    xpFed: Int
}

type MatchPlayerStatsFarmDistributionObjectType {
    count: Int!
    gold: Int
    id: Int!
    xp: Int
}

type MatchPlayerStatsFarmDistributionReportType {
    abandonGold: Int!
    ancientLocation: [MatchPlayerStatsFarmDistributionObjectType]
    bountyGold: MatchPlayerStatsFarmDistributionObjectType
    buildings: [MatchPlayerStatsFarmDistributionObjectType]
    buyBackGold: Int!
    creepLocation: [MatchPlayerStatsFarmDistributionObjectType]
    creepType: [MatchPlayerStatsFarmDistributionObjectType]
    neutralLocation: [MatchPlayerStatsFarmDistributionObjectType]
    other: [MatchPlayerStatsFarmDistributionObjectType]
}

type MatchPlayerStatsHeroDamageReportType {
    dealtSourceAbility: [MatchPlayerHeroDamageSourceAbilityReportObjectType]
    dealtSourceItem: [MatchPlayerHeroDamageSourceItemReportObjectType]
    dealtTargets: [MatchPlayerHeroDamageTargetReportObjectType]
    dealtTotal: MatchPlayerHeroDamageTotalReportObjectType
    receivedSourceAbility: [MatchPlayerHeroDamageSourceAbilityReportObjectType]
    receivedSourceItem: [MatchPlayerHeroDamageSourceItemReportObjectType]
    receivedTargets: [MatchPlayerHeroDamageTargetReportObjectType]
    receivedTotal: MatchPlayerHeroDamageTotalRecievedReportObjectType
}

type MatchPlayerStatsItemUsedEventType {
    count: Int
    itemId: Int!
}

type MatchPlayerStatsKillEventType {
    assist: [Int!]
    byAbility: Int
    byItem: Int
    gold: Int
    isGank: Boolean
    isInvisible: Boolean
    isSmoke: Boolean
    isSolo: Boolean
    isTpRecently: Boolean
    positionX: Int
    positionY: Int
    target: Int
    time: Int!
    xp: Int
}

type MatchPlayerStatsLocationReportType {
    positionX: Int!
    positionY: Int!
}

type MatchPlayerStatsRuneEventType {
    action: RuneAction
    gold: Int
    positionX: Int
    positionY: Int
    rune: RuneEnums
    time: Int!
}

type MatchPlayerStatsTowerDamageReportType {
    damage: Int!
    damageCreeps: Int!
    damageFromAbility: Int!
    npcId: Int!
}

type MatchPlayerStatsType {
    abilityCastReport: [MatchPlayerStatsAbilityCastReportType]
    actionReport: MatchPlayerStatsActionReportType
    actionsPerMinute: [Int]
    allTalks: [MatchPlayerStatsAllTalkEventType]
    assistEvents: [MatchPlayerStatsAssistEventType]
    campStack: [Int]
    chatWheels: [MatchPlayerStatsChatWheelEventType]
    courierKills: [MatchPlayerStatsCourierKillEventType]
    deathEvents: [MatchPlayerStatsDeathEventType]
    deniesPerMinute: [Int]
    experiencePerMinute: [Int]
    farmDistributionReport: MatchPlayerStatsFarmDistributionReportType
    gameVersionId: Short
    goldPerMinute: [Int]
    healPerMinute: [Int]
    heroDamagePerMinute: [Int]
    heroDamageReceivedPerMinute: [Int]
    heroDamageReport: MatchPlayerStatsHeroDamageReportType
    impPerMinute: [Int]
    inventoryReport: [MatchPlayerInventoryType]
    itemPurchases: [MatchPlayerItemPurchaseEventType]
    itemUsed: [MatchPlayerStatsItemUsedEventType]
    killEvents: [MatchPlayerStatsKillEventType]
    lastHitsPerMinute: [Int]
    level: [Int]
    locationReport: [MatchPlayerStatsLocationReportType]
    matchId: Long
    matchPlayerBuffEvent: [MatchPlayerStatsBuffEventType]
    networthPerMinute: [Int]
    runes: [MatchPlayerStatsRuneEventType]
    spiritBearInventoryReport: [MatchPlayerSpiritBearInventoryType]
    steamAccountId: Long
    towerDamagePerMinute: [Int]
    towerDamageReport: [MatchPlayerStatsTowerDamageReportType]
    tripsFountainPerMinute: [Int]
    wardDestruction: [MatchPlayerWardDestuctionObjectType]
    wards: [MatchPlayerStatsWardEventType]
}

type MatchPlayerStatsWardEventType {
    positionX: Int
    positionY: Int
    time: Int!
    type: Int!
}

type MatchPlayerType {
    abilities(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVerionId: Int
    ): [PlayerAbilityType]
    additionalUnit: MatchPlayerAdditionalUnitType
    assists: Byte
    award: MatchPlayerAward
    backpack0Id: Short
    backpack1Id: Short
    backpack2Id: Short
    behavior: Short
    deaths: Byte
    "Gets the players of Dota which have DotaPlus and have a high level hero."
    dotaPlus: HeroDotaPlusLeaderboardRankType
    dotaPlusHeroXp: Int
    experiencePerMinute: Short
    gameVersionId: Short
    gold: Int
    goldPerMinute: Short
    goldSpent: Int
    hero: HeroType
    "Detailed output of data per minute for each hero."
    heroAverage: [HeroPositionTimeDetailType]
    heroDamage: Int
    heroHealing: Int
    heroId: Short
    imp: Short
    intentionalFeeding: Boolean
    invisibleSeconds: Int
    isRadiant: Boolean
    isRandom: Boolean
    isVictory: Boolean
    item0Id: Short
    item1Id: Short
    item2Id: Short
    item3Id: Short
    item4Id: Short
    item5Id: Short
    kills: Byte
    lane: MatchLaneType
    leaverStatus: LeaverStatusEnum
    level: Byte
    match: MatchType
    matchId: Long
    networth: Int
    "The item id of the dedicated neutral item slot (7.24 and after). From game versions 7.23 to 7.24, this was the BackPack3Id (the 4th backpack slot item id)."
    neutral0Id: Short
    numDenies: Short
    numLastHits: Short
    partyId: Byte
    playbackData: MatchPlayerPlaybackDataType
    playerSlot: Byte
    position: MatchPlayerPositionType
    role: MatchPlayerRoleType
    roleBasic: MatchPlayerRoleType
    stats: MatchPlayerStatsType
    steamAccount: SteamAccountType
    steamAccountId: Long
    streakPrediction: Short
    towerDamage: Int
}

type MatchPlayerWardDestuctionObjectType {
    experience: Int
    gold: Int
    isWard: Boolean
    time: Int!
}

type MatchReplayUploadHeroDuoSummaryType {
    heroId: Short
    matchCountAgainst: Int!
    matchCountWith: Int!
    winCountAgainst: Int!
    winCountWith: Int!
}

type MatchReplayUploadHeroSummaryType {
    banCountAgainst: Int!
    banCountWith: Int!
    duos: [MatchReplayUploadHeroDuoSummaryType]
    heroId: Short
    matchCountAgainst: Int!
    matchCountWith: Int!
    winCountAgainst: Int!
    winCountWith: Int!
}

type MatchReplayUploadMatchType {
    didRadiantWin: Boolean!
    direKills: Byte
    direTeam: TeamType
    direTeamId: Int
    durationMinutes: Int!
    durationSeconds: Short
    endDateTime: DateTime
    fileName: String!
    gameMode: Byte
    gameVersionId: Int!
    id: Long
    isActive: Boolean!
    isComplete: Boolean!
    isRadiantFirstPick: Boolean!
    isValidated: Boolean!
    league: LeagueType
    leagueId: Int
    lobbyType: Byte
    matchUploadTeamId: Long!
    notes: String
    numHumanPlayers: Byte
    numHumanSpectators: Byte
    pickBans: [MatchReplayUploadPickBanType]
    players: [MatchReplayUploadPlayerType]
    radiantKills: Byte
    radiantTeam: TeamType
    radiantTeamId: Int
    seriesId: Long
    spectators: [Long]
    startDateTime: DateTime
    uploaderCaptainJackIdentityId: Guid
}

type MatchReplayUploadOverviewType {
    matchCount: Int!
    matches: [MatchReplayUploadMatchType]
    winCount: Int!
}

type MatchReplayUploadPickBanType {
    bannedHeroId: Short
    heroId: Short
    isPick: Boolean!
    isRadiant: Boolean
    order: Byte
    playerSlot: Byte
    time: Byte
    wasBannedSuccessfully: Boolean!
}

type MatchReplayUploadPlayerStatsItemsType {
    backpack0IdList: [Byte]
    backpack1IdList: [Byte]
    backpack2IdList: [Byte]
    item0IdList: [Byte]
    item1IdList: [Byte]
    item2IdList: [Byte]
    item3IdList: [Byte]
    item4IdList: [Byte]
    item5IdList: [Byte]
}

type MatchReplayUploadPlayerType {
    agilityTotalList: [Int]
    assists: Byte
    assistsList: [Int]
    backpack0Id: Short
    backpack1Id: Short
    backpack2Id: Short
    bkbChargesUsedList: [Int]
    campStackList: [Int]
    claimedDenyCountList: [Int]
    claimedMissCountList: [Int]
    commandsIssuedList: [Int]
    creepKillGoldList: [Int]
    creepStackList: [Int]
    damageBonusList: [Int]
    damageMaxList: [Int]
    damageMinList: [Int]
    deaths: Byte
    deathsList: [Int]
    denies: Short
    denyCountList: [Int]
    experiencePerMinute: Short
    goldLostToDeathList: [Int]
    goldPerMinute: Short
    goldSpentOnBuybacks: Int
    goldSpentOnBuybacksList: [Int]
    goldSpentOnConsumables: Int
    goldSpentOnConsumablesList: [Int]
    goldSpentOnItems: Int
    goldSpentOnItemsList: [Int]
    goldSpentOnSupport: Int
    goldSpentOnSupportList: [Int]
    heroDamage: Int!
    heroDamageList: [Int]
    heroHealing: Int!
    heroHealingList: [Int]
    heroId: Short
    heroKillGoldList: [Int]
    incomeGoldList: [Int]
    intellectTotalList: [Int]
    isDire: Boolean!
    isRadiant: Boolean!
    isVictory: Boolean!
    item0Id: Short
    item1Id: Short
    item2Id: Short
    item3Id: Short
    item4Id: Short
    item5Id: Short
    items: MatchReplayUploadPlayerStatsItemsType
    kills: Byte
    killsList: [Int]
    lane: MatchLaneType
    lastHitCountList: [Int]
    lastHitMultiKillList: [Int]
    lastHitStreakList: [Int]
    lastHits: Short
    level: Byte
    levelList: [Int]
    matchId: Long
    matchUploadTeamId: Long!
    maxHealthList: [Int]
    maxManaList: [Int]
    missCountList: [Int]
    nearbyCreepDeathCountList: [Int]
    networth: Int!
    networthList: [Int]
    observerWardsPlacedList: [Int]
    pickOrder: Byte
    playerSlot: Byte
    position: MatchPlayerPositionType
    reliableGoldList: [Int]
    role: MatchPlayerRoleType
    roshanKillsList: [Int]
    runePicksupList: [Int]
    sentryWardsPlacedList: [Int]
    sharedGoldList: [Int]
    steamAccount: SteamAccountType
    steamAccountId: Long
    streakList: [Int]
    strengthTotalList: [Int]
    stunsList: [Int]
    teamPickOrder: MatchPlayerTeamPickOrderType
    teamSlot: Byte
    totalEarnedGoldList: [Int]
    totalEarnedXpList: [Int]
    totalGoldSpent: Int!
    towerDamage: Int!
    towerDamageList: [Int]
    towerKills: Short
    towerKillsList: [Int]
    unreliableGoldList: [Int]
    wardsDestroyedList: [Int]
    wardsPurchasedList: [Int]
}

type MatchReplayUploadTeamMemberType {
    captainJackIdentityId: Guid
    isAdmin: Boolean!
    isDefaultTeam: Boolean!
    matchUploadTeamId: Long!
    steamAccount: SteamAccountType
}

type MatchReplayUploadTeamType {
    creatorCaptainJackIdentityId: Guid
    email: String!
    id: Long!
    isDefault: Boolean
    members: [MatchReplayUploadTeamMemberType]
    name: String!
    team: TeamType
    teamId: Int!
}

type MatchStatsChatEventType {
    fromHeroId: Short
    isRadiant: Boolean
    pausedTick: Int
    time: Int
    toHeroId: Short
    type: Int
    value: Short
}

type MatchStatsLaneReportFactionLaneObject {
    denyCount: Int!
    meleeCount: Int!
    neutralCount: Int!
    rangeCount: Int!
    siegeCount: Int!
}

type MatchStatsLaneReportFactionObjectType {
    midLane: MatchStatsLaneReportFactionLaneObject
    offLane: MatchStatsLaneReportFactionLaneObject
    safeLane: MatchStatsLaneReportFactionLaneObject
}

type MatchStatsLaneReportType {
    dire: [MatchStatsLaneReportFactionObjectType]
    radiant: [MatchStatsLaneReportFactionObjectType]
}

type MatchStatsOutpostReportObjectType {
    isControlledByRadiant: Boolean!
    isRadiantSide: Boolean!
    npcId: Int
}

type MatchStatsPickBanType {
    adjustedWinRate: Byte
    bannedHeroId: Short
    baseWinRate: Byte
    heroId: Short
    isPick: Boolean!
    isRadiant: Boolean
    letter: Int
    order: Int
    playerIndex: Int
    team: Int
    wasBannedSuccessfully: Boolean
}

type MatchStatsTowerDeathType {
    attacker: Short
    isRadiant: Boolean
    npcId: Short
    time: Int
}

type MatchStatsTowerReportObjectType {
    hp: Int
    npcId: Int
}

type MatchStatsTowerReportType {
    outposts: [MatchStatsOutpostReportObjectType]
    towers: [MatchStatsTowerReportObjectType]
}

type MatchType {
    actualRank: Short
    analysisOutcome: MatchAnalysisOutcomeType
    averageImp: Short
    averageRank: Short
    barracksStatusDire: Short
    barracksStatusRadiant: Short
    bottomLaneOutcome: LaneOutcomeEnums
    bracket: Byte
    chatEvents: [MatchStatsChatEventType]
    clusterId: Int
    didRadiantWin: Boolean
    didRequestDownload: Boolean
    "This begins at -60 to 0 seconds (Index 0)."
    direKills: [Int]
    direTeam: TeamType
    direTeamId: Int
    durationSeconds: Int
    endDateTime: Long
    firstBloodTime: Int
    gameMode: GameModeEnumType
    gameVersionId: Short
    id: Long
    isStats: Boolean
    laneReport: MatchStatsLaneReportType
    league: LeagueType
    leagueId: Int
    lobbyType: LobbyTypeEnum
    midLaneOutcome: LaneOutcomeEnums
    numHumanPlayers: Int
    parsedDateTime: Long
    "This begins at -60 to 0 seconds (Index 0)."
    pickBans: [MatchStatsPickBanType]
    playbackData: MatchPlaybackDataType
    players(
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long
    ): [MatchPlayerType]
    predictedOutcomeWeight: Byte
    predictedWinRates: [Decimal]
    "This begins at -60 to 0 seconds (Index 0)."
    radiantExperienceLeads: [Int]
    "This begins at -60 to 0 seconds (Index 0)."
    radiantKills: [Int]
    "This begins at -60 to 0 seconds (Index 0)."
    radiantNetworthLeads: [Int]
    radiantTeam: TeamType
    radiantTeamId: Int
    rank: Int
    regionId: Byte
    replaySalt: Long
    sequenceNum: Long
    series: SeriesType
    seriesId: Long
    spectators: [MatchPlayerSpectatorType]
    startDateTime: Long
    statsDateTime: Long
    topLaneOutcome: LaneOutcomeEnums
    tournamentId: Int
    tournamentRound: Short
    towerDeaths: [MatchStatsTowerDeathType]
    towerStatus: [MatchStatsTowerReportType]
    towerStatusDire: Int
    towerStatusRadiant: Int
    winRates: [Decimal]
}

type MatchesDayType {
    day: Long!
    matchCount: Int!
}

type MatchesGameVersionType {
    gameVersionId: Short!
    matchCount: Int!
}

type MatchesHourType {
    hour: Long!
    matchCount: Int!
}

type MatchesMonthType {
    matchCount: Int!
    month: Long!
}

type MatchesWeekType {
    matchCount: Int!
    week: Long!
}

type MatchmakingStatsType {
    australia: Int!
    austria: Int!
    brazil: Int!
    chile: Int!
    dubai: Int!
    europe: Int!
    india: Int!
    japan: Int!
    perfectWorldTelecom: Int!
    perfectWorldTelecomGuangdong: Int!
    perfectWorldTelecomWuhan: Int!
    perfectWorldTelecomZhejiang: Int!
    perfectWorldUnicom: Int!
    perfectWorldUnicomTianjin: Int!
    peru: Int!
    singapore: Int!
    southAfrica: Int!
    stockholm: Int!
    taiwan: Int!
    time: Long!
    uSEast: Int!
    uSWest: Int!
}

type MatchplaybackDataCourierEventObjectType {
    didCastBoost: Boolean
    hp: Int
    isFlying: Boolean
    item0Id: Int
    item1Id: Int
    item2Id: Int
    item3Id: Int
    item4Id: Int
    item5Id: Int
    positionX: Int
    positionY: Int
    respawnTime: Int
    time: Int!
}

type ModifierType {
    buffDuration: Int
    id: Short
    isArmorReduce: Boolean
    isAttackReduce: Boolean
    isAttackSlow: Boolean
    isBanished: Boolean
    isBlind: Boolean
    isBreak: Boolean
    isCyclone: Boolean
    isDamageAmplified: Boolean
    isDisarm: Boolean
    isEthereal: Boolean
    isHex: Boolean
    isInvisible: Boolean
    isItem: Boolean
    isKnockback: Boolean
    isMovementDebuff: Boolean
    isMovementSlow: Boolean
    isMute: Boolean
    isRoot: Boolean
    isShackle: Boolean
    isSilence: Boolean
    isSleep: Boolean
    isStun: Boolean
    isTaunt: Boolean
    isWeaken: Boolean
    name: String
}

type NewsItemType {
    author: String!
    contents: String!
    date: Long
    feedLabel: String!
    feedName: String!
    id: Long
    title: String!
    uri: String!
}

type NpcStatType {
    attackAnimationPoint: Float
    attackDamageMax: Float
    attackDamageMin: Float
    attackDesire: Float
    attackRange: Float
    attackRangeBuffer: Float
    attackRate: Float
    autoAttacksByDefault: Boolean
    canBeDominated: Boolean
    combatClassAttack: String
    combatClassDefend: String
    dayTimeVision: Float
    hasInventory: Boolean
    isAncient: Boolean
    isNeutralUnitType: Boolean
    level: Float
    movementSpeed: Float
    movementTurnRate: Float
    nightTimeVision: Float
    projectileSpeed: Float
    statusHealth: Float
    statusHealthRegen: Float
    statusMana: Float
    statusManaRegen: Float
    teamName: String
    unitRelationshipClass: String
    wakesNeutrals: Boolean
}

type NpcType {
    id: Short
    name: String
    stat: NpcStatType
}

type PageAghanimQuery {
    "Returns all the Abilities for a Hero on the Event Aghanim Labyrinth."
    heroAbility(difficulty: AghanimLabMatchDifficultyEnum!): [AghanimLabHeroAbilityType]
    "Returns all the combinations of Heroes and their success on the Event Aghanim Labyrinth."
    heroComposition(difficulty: AghanimLabMatchDifficultyEnum!, heroIds: [Short]!): AghanimLabHeroCompositionType
    "Returns all the combinations of Heroes and their success on the Event Aghanim Labyrinth."
    heroCompositions(request: FilterAghanimLabHeroCompositionRequestType!): [AghanimLabHeroCompositionType]
    "Returns a match by Id based on the Event Aghanim Labyrinth."
    match(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        id: Long!
    ): AghanimLabMatchType
    "Returns a list of matches by based on the Event Aghanim Labyrinth."
    matches(request: FilterAghanimLabMatchRequestType): [AghanimLabMatchType]
    "Returns all the Room Types by Difficulty for the Event Aghanim Labyrinth."
    room(difficulty: AghanimLabMatchDifficultyEnum!): [AghanimLabRoomType]
    "Returns all the Room Modifiers by Difficulty for the Event Aghanim Labyrinth."
    roomModifier(difficulty: AghanimLabMatchDifficultyEnum!): [TI2020CustomGameRoomModifierType]
    "Returns the last 3 days winrate for each hero by Difficulty in the Event Aghanim Labyrinth."
    winRate(difficulty: AghanimLabMatchDifficultyEnum!): AghanimLabHeroWinRateType
}

type PageBattlepassQuery {
    predictionsHero(
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        leagueIds: [Int]!
    ): [BattlepassPredictionHeroType]
    predictionsPlayers(
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        leagueIds: [Int]!,
        "An array of team ids to include in this query, excluding all results that do not have this team id."
        teamIds: [Int]!
    ): [BattlepassPredictionPlayerType]
    predictionsTeams(
        "This will alter the team data to take the average of the matches if true. If false, it will find the top instance for each category (1)."
        averaged: Boolean,
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        leagueIds: [Int]!,
        "An array of team ids to include in this query, excluding all results that do not have this team id."
        teamIds: [Int]!
    ): [BattlepassPredictionTeamType]
    predictionsTournament(
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        leagueIds: [Int]!,
        "An array of team ids to include in this query, excluding all results that do not have this team id."
        teamIds: [Int]!
    ): BattlepassPredictionTournamentType
}

type PageDireTideQuery {
    "Returns a match by Id based on the Halloween Event DireTide."
    match(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        id: Long!
    ): DireTideCustomGameMatchType
    "Returns a list of matches by based on the Halloween Event DireTide."
    matches(request: FilterDireTideCustomMatchRequestType!): [DireTideCustomGameMatchType]
    "Returns the last 12 days by day showing the amount of matches and the amount of wins by hero id."
    winDay(
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [DireTideCustomGameHeroWinDayType]
}

type PageLeaguesQuery {
    "Returns the last 12 hours by hour showing the amount of matches."
    dpcPositionStats: [LeagueDpcPositionStatObjectType]
}

type PageMatchesQuery {
    "Returns the last 12 days by day showing the amount of matches."
    matchesStatsDay(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [MatchesDayType]
    "Returns the data by game version showing the amount of matches."
    matchesStatsGameVersion(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [MatchesGameVersionType]
    "Returns the last 12 hours by hour showing the amount of matches."
    matchesStatsHour(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [MatchesHourType]
    "Returns the data by month showing the amount of matches."
    matchesStatsMonth(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [MatchesMonthType]
    "Returns the last 12 weeks by week showing the amount of matches."
    matchesStatsWeek(
        "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
        bracketIds: [RankBracket],
        "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
        gameModeIds: [GameModeEnumType],
        "An array of region ids to include in this query, excluding all results that do not include one of these regions."
        regionIds: [BasicRegionType],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [MatchesWeekType]
    "Amount of players who are active and searching for a game in this region."
    matchmakingStats: [MatchmakingStatsType]
}

type PagePlayerQuery {
    "Returns a general player summary of random set of predefinded filters."
    breakdown(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerBreakdownRequestType!
    ): PlayerBreakdownType
    "Returns the violations commited by a player in their last 500 games."
    conduct: PlayerConductResponseType
    "A more in depth at a single player's single hero performance."
    heroPerformance(
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "The request object used to filter matches returned based on input criteria."
        request: PlayerHeroPerformanceMatchesRequestType!
    ): PlayerPerformanceType
    "Returns a list of all heroes played by the steam account id and contains data about the average performance."
    heroesPerformance(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerHeroesPerformanceMatchesRequestType
    ): [PlayerHeroesPerformanceType]
    "Returns a list of players that the player has played with."
    peers(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerTeammatesGroupByRequestType!,
        "Normally, you use Skip inside the request object.  But due to Skip being used to determine how many matches to look at, this skip will skip the amount of rows being returned from the results."
        skip: Int,
        "Normally, you use Take inside the request object.  But due to Take being used to determine how many matches to look at, this take will limit the amount of rows being returned from the results."
        take: Int
    ): [PlayerTeammateType]
    "Provided in-depth look of a player and how they proform globally on all heroes."
    performance(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerPerformanceMatchesRequestType!
    ): PlayerPerformanceType
    "Picked the top pros and annoucers and determines if you ever have played with them and when."
    playedWithPro: PlayerPlayedWithProType
    "Get very simple data for the on-hover of a player icon."
    simpleSummary: PlayerCardHoverType
}

type PagePlayersQuery {
    "Endpoint which breaks down all the SteamAccounts in the database by their current season rank."
    steamAccountByRank(
        "The week to include in this query, excluding all results that do not include this week. The value is an epoc TimeStamp of the week of data you want. Leaving null gives the current week."
        week: Long
    ): [SteamAccountByRankType]
}

type PageQuery {
    "Endpoints for the TI10 (2020) regarding the summer event."
    aghanim: PageAghanimQuery
    "Endpoints for the battlepass data."
    battlePass: PageBattlepassQuery
    direTide: PageDireTideQuery
    "Endpoints for Imp Related calls."
    imp: ImpQuery
    "STRATZ specific endpoints found on the /leagues/ section of the website. "
    leagues: PageLeaguesQuery
    "STRATZ specific endpoints found on the /matches/ section of the website. "
    matches: PageMatchesQuery
    "STRATZ specific endpoints found on the /player/ section of the website. id is a required input field."
    player(
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long!
    ): PagePlayerQuery
    "STRATZ specific endpoints found on the /players/ section of the website. "
    players: PagePlayersQuery
    rosh: RoshQuery
}

type PatchNoteLanguageType {
    abilityId: Short
    gameVersionId: Short
    generalId: PatchNoteType
    heroId: Short
    id: String
    index: Byte
    itemId: Short
    languageId: Byte
    text: String
}

type PlayerAbilityType {
    abilityId: Int!
    abilityType(
        "The game version id to include in this query, excluding all results that do not have this game version."
        gameVerionId: Int,
        "The language id to include in this query, excluding all results that do not have this language."
        langaugeId: Int
    ): AbilityType
    gameVersionId: Short
    isTalent: Boolean
    level: Int!
    time: Int!
}

type PlayerActivitySummaryType {
    activity: PlayerBehaviorActivity
}

type PlayerBadgeType {
    badgeId: Byte
    createdDateTime: Long
    slot: Byte
}

type PlayerBattlePassGroupByType {
    id: String
    playerCount: Long
    playerCountAt1000: Long
    sumLevels: Long
}

type PlayerBattlePassResponseType {
    levels: [Int!]!
    players(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [PlayerBattlePassType]
}

type PlayerBattlePassType {
    level: Int!
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type PlayerBreakdownObjectType {
    id: Int
    imp: Int
    lastSeenDateTime: Long
    matchCount: Int!
    win: Int
}

type PlayerBreakdownType {
    dayOfWeekMatches: [PlayerBreakdownObjectType]
    durationMatches: [PlayerBreakdownObjectType]
    factionMatches: [PlayerBreakdownObjectType]
    gameModeMatches: [PlayerBreakdownObjectType]
    heroAttributeMatches: [PlayerBreakdownObjectType]
    impMatches: [PlayerBreakdownObjectType]
    isStatsMatches: [PlayerBreakdownObjectType]
    laneMatches: [PlayerBreakdownObjectType]
    lobbyMatches: [PlayerBreakdownObjectType]
    matches: PlayerBreakdownObjectType
    partyMatches: [PlayerBreakdownObjectType]
    rankMatches: [PlayerBreakdownObjectType]
    regionMatches: [PlayerBreakdownObjectType]
    roleMatches: [PlayerBreakdownObjectType]
    timeOfDayMatches: [PlayerBreakdownObjectType]
    weekEndMatches: [PlayerBreakdownObjectType]
}

type PlayerCardHoverHeroType {
    heroId: Int!
    lossCount: Int!
    winCount: Int!
}

type PlayerCardHoverType {
    activity: Byte
    coreCount: Int
    heroes: [PlayerCardHoverHeroType]
    imp: Int
    lastUpdateDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    supportCount: Int
}

type PlayerCoachingLeaderboardResponseType {
    levels: [Int!]!
    players(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [PlayerCoachingLeaderboardType]
}

type PlayerCoachingLeaderboardType {
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int!
    rating: Int!
    steamAccount: SteamAccountType
    steamAccountId: Long!
    winCount: Int!
}

type PlayerConductResponseType {
    behaviorScore: Short
    lastIncidentDateTime: Long
    lastIncidentMatchId: Long
    recentMatchIncidents: [Short]
}

type PlayerDraftHeroHighlightType {
    impAllTime: Int
    impLastMonth: Int
    impLastSixMonths: Int
    lastPlayed: Long
    matchCount: Int
    matchCountLastMonth: Int
    matchCountLastSixMonths: Int
    mvpCountLastMonth: Int
    topCoreCountLastMonth: Int
    topSupportCountLastMonth: Int
    winCount: Int
    winCountLastMonth: Int
    winCountLastSixMonths: Int
}

type PlayerHeroDotaPlusLeaderboardRankResponseType {
    players: [HeroDotaPlusLeaderboardRankType]
}

type PlayerHeroPerformanceLongestStreakType {
    currentStreak: Int
    heroId: Short
    longestStreak: Int
}

type PlayerHeroesPerformanceScoreType {
    id: MatchPlayerPositionType
    imp: Int
    matchCount: Int!
    score: Float!
    winCount: Int!
}

type PlayerHeroesPerformanceType {
    avgAssists: Float
    avgDeaths: Float
    avgKills: Float
    best: Float
    duration: Int!
    experiencePerMinute: Int!
    goldPerMinute: Int!
    hero: HeroType
    heroId: Short!
    imp: Int
    kDA: Float
    lastPlayedDateTime: Long
    matchCount: Int!
    positionScore: [PlayerHeroesPerformanceScoreType]
    winCount: Int!
}

type PlayerLeaderBoardByHeroType {
    changeInRanking: Short
    createdDateTime: Long
    heroId: Short
    impAverage: Byte
    losses: Byte
    position: MatchPlayerPositionType
    regionId: Byte
    seasonBracket: Byte
    steamAccount: SteamAccountType
    steamAccountId: Long
    winStreak: Byte
    wins: Byte
}

type PlayerPerformanceCompositionHeroType {
    heroId: Short
    matchCount: Int!
    winCount: Int!
}

type PlayerPerformanceCompositionType {
    allies: [PlayerPerformanceCompositionHeroType]
    foes: [PlayerPerformanceCompositionHeroType]
}

type PlayerPerformancePositionObjectType {
    laneMatchCount: Int!
    laneType: Byte
    laneWinCount: Int!
}

type PlayerPerformancePositionType {
    lanes: [PlayerPerformancePositionObjectType]
    roleMatchCount: Int!
    roleType: MatchPlayerRoleType
    roleWinCount: Int!
}

type PlayerPerformanceType {
    assists: Int
    assistsAverage: Decimal
    awardMatchCount: Int!
    composition: PlayerPerformanceCompositionType
    cs: Int
    csAverage: Decimal
    deaths: Int
    deathsAverage: Decimal
    gpm: Int
    gpmAverage: Decimal
    heroId: [Short]
    imp: Int
    kills: Int
    killsAverage: Decimal
    matchCount: Int!
    maxStreak: Int!
    mmrBracket: Int!
    mmrTier: Int!
    mvpCount: Int!
    "Contains an array of 6 items which are listed as index 0 - 1st Pick, Index 1 - Pick 2nd, 3rd, Index 2 - Pick 4th, 5th, Index 3 - Pick 6th, Pick 7th, Index 4 - Pick 8th, 9ths, Index 5 - Pick 10th"
    pickOrder: [Int]
    position: [PlayerPerformancePositionType]
    rank: Int
    streak: Int!
    topCoreCount: Int!
    topSupportCount: Int!
    winCount: Int!
    xpm: Int
    xpmAverage: Decimal
}

type PlayerPlayedWithProPlayerMatchType {
    match: MatchType
    matchId: Long
}

type PlayerPlayedWithProPlayerType {
    steamAccount: SteamAccountType
    steamId: Long
    vs: PlayerPlayedWithProPlayerMatchType
    with: PlayerPlayedWithProPlayerMatchType
}

type PlayerPlayedWithProTeamType {
    players: [PlayerPlayedWithProPlayerType]
    teamId: Int!
    teamLogo: String!
    teamName: String!
}

type PlayerPlayedWithProType {
    casters: [PlayerPlayedWithProPlayerType]
    internationalWinners: [PlayerPlayedWithProTeamType]
    playedCount: Int!
    teams: [PlayerPlayedWithProTeamType]
    totalCount: Int!
}

type PlayerRuneDetailType {
    action: RuneAction
    gold: Int
    positionX: Int
    positionY: Int
    rune: RuneEnums
    time: Int!
}

type PlayerTeammateType {
    avgAssists: Float
    avgDeaths: Float
    avgExperiencePerMinute: Int
    avgGoldPerMinute: Int
    avgImp: Int
    avgKDA: Float
    avgKills: Float
    firstMatchDateTime: Long
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
    winCount: Int
}

type PlayerType {
    activity: PlayerActivitySummaryType
    badges: [PlayerBadgeType]
    behaviorScore: Short
    "Gets the players of Dota which have DotaPlus and have a high level hero."
    dotaPlus: [HeroDotaPlusLeaderboardRankType]
    "A list of the high achivement skills by a Player."
    feats(skip: Int, take: Int): [FeatType]
    firstMatchDate: Long
    guildMember: GuildMemberType
    heroPerformance(
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "The request object used to filter matches returned based on input criteria."
        request: PlayerHeroPerformanceMatchesRequestType!
    ): PlayerPerformanceType
    "A list of the current Streak and the Longest Streak for each Hero by a Player."
    heroStreaks(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerMatchesRequestType
    ): [PlayerHeroPerformanceLongestStreakType]
    "Returns a list of all heroes played by the steam account id and contains data about the average performance."
    heroesPerformance(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerHeroPerformanceMatchesRequestType,
        "Normally, you use Skip inside the request object.  But due to Skip being used to determine how many matches to look at, this skip will skip the amount of rows being returned from the results."
        skip: Int,
        "Normally, you use Take inside the request object.  But due to Take being used to determine how many matches to look at, this take will limit the amount of rows being returned from the results."
        take: Int
    ): [PlayerHeroesPerformanceType]
    identity: CaptainJackIdentityPublicProfileType
    imp: Int
    isFollowed: Boolean
    lastMatchDate: Long
    lastMatchRegionId: Byte
    leaderboardRanks(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [SteamAccountSeasonLeaderBoardRankType]
    matchCount: Int
    "Find match details by steam account id. steamAccountId is a required input field."
    matches(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerMatchesRequestType!
    ): [MatchType]
    "Find match details by steam account id. The return is modified to group the data by the GroupBy parameter."
    matchesGroupBy(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerMatchesGroupByRequestType!
    ): [MatchGroupByType]
    names(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [SteamAccountNameType]
    performance: PlayerPerformanceType
    ranks(
        "An array of season in which Dota creates each year for ranks."
        seasonRankIds: [Byte]
    ): [SteamAccountSeasonRankType]
    simpleSummary: PlayerCardHoverType
    steamAccount: SteamAccountType
    steamAccountId: Long
    team: SteamAccountTeamMemberType
    winCount: Int
}

type PlayerUpdateAttributeDetailType {
    agi: Int!
    int: Int!
    str: Int!
    time: Int!
}

type PlayerUpdateBattleDetailType {
    damageBonus: Int!
    damageMinMax: Int!
    hpRegen: Int!
    mpRegen: Int!
    time: Int!
}

type PlayerUpdateGoldDetailType {
    gold: Int!
    networth: Int!
    networthDifference: Int!
    time: Int!
    unreliableGold: Int!
}

type PlayerUpdateHealthDetailType {
    hp: Int!
    maxHp: Int!
    maxMp: Int!
    mp: Int!
    time: Int!
}

type PlayerUpdateLevelDetailType {
    level: Int!
    time: Int!
}

type PlayerUpdatePositionDetailType {
    time: Int!
    x: Int!
    y: Int!
}

type PlusDraftPlayerHeroObjectType {
    heroId: Short
    letter: PlusLetterType
    pickValue: Decimal
    score: Float
    winValues: [Decimal]
}

type PlusDraftPlayerType {
    heroes: [PlusDraftPlayerHeroObjectType]
    position: MatchPlayerPositionType
    positionValues: [Decimal]
    slot: Byte
}

type PlusDraftType {
    durationValues: [Decimal]
    midOutcome: Decimal
    offOutcome: Decimal
    players: [PlusDraftPlayerType]
    safeOutcome: Decimal
    winValues: [Decimal]
}

type PlusHeroTeamStatusAveragesType {
    cs: Decimal
    deaths: Decimal
    disableCount: Decimal
    disableDuration: Decimal
    healingAllies: Decimal
    magicalDamage: Decimal
    magicalDamageReceived: Decimal
    physicalDamage: Decimal
    physicalDamageReceived: Decimal
    pureDamage: Decimal
    pureDamageReceived: Decimal
    purgeModifiers: Decimal
    slowCount: Decimal
    slowDuration: Decimal
    stunCount: Decimal
    stunDuration: Decimal
    towerDamage: Decimal
    weakenCount: Decimal
    weakenDuration: Decimal
}

type PlusHeroTeamStatusDetailType {
    averages: PlusHeroTeamStatusAveragesType
    basicBracket: RankBracketBasicEnum
    heroId: Int!
    position: MatchPlayerPositionType
}

type PlusHoverBanType {
    flags: Byte
    heroId: Short
    score: Decimal
}

type PlusHoverType {
    bans: [PlusHoverBanType]
    players: [PlusPlayerHoverType]
}

type PlusPlayerHoverHeroType {
    heroId: Short
    lossCount: Int!
    winCount: Int!
}

type PlusPlayerHoverPlayerType {
    lastMatchDateTime: Long
    matchCount: Int!
    steamAccountId: Long
    winCount: Int!
}

type PlusPlayerHoverType {
    activity: Byte
    behaviorScore: Short
    coreCount: Int
    enemies: [PlusPlayerHoverPlayerType]
    friends: [PlusPlayerHoverPlayerType]
    heroes: [PlusPlayerHoverHeroType]
    heroesExperience: [Short]
    imp: Int
    languageCode: [String]
    lastMatchDateTime: Long
    matchCount: Int
    steamAccount: SteamAccountType
    supportCount: Int
    winCount: Int!
}

type PlusQuery {
    "The main call for STRATZ Plus. It will return back probability data based on a draft of players that were given."
    draft(
        "The main call for STRATZ Plus. It will return back probability data based on a draft of players that were given."
        request: PlusDraftRequestType!
    ): PlusDraftType
    "To save CPU cycles we limit the amount of heroes a person can play. If a player picks a hero outside the default list, we have no idea how good the hero would of been. You can call this endpoint to update the grade letter for that hero selection."
    draftMissingLetter(request: PlusDraftMissingLetterRequestType!): PlusLetterType
    "Returns back basic data about the user playing a specific hero.  Used in the Draft app to show post-pick data."
    playerHeroHighlight(
        "The hero id to include in this query, excluding all results that do not include this hero."
        heroId: Short!,
        "The Steam Account Id to look up. If the person is anonymous, you will get a null."
        steamAccountId: Long!
    ): PlayerDraftHeroHighlightType
    "Gets a list of data of the players in the match, can send a max of 10 people.  If a user blocks their data on STRATZ, that data will not be returned."
    playerMatchHistory(
        "The request object that will filter your PlusPlayerHover data."
        request: PlusPlayerHoverRequestType!
    ): PlusHoverType
    "Returns a set of events which contain each hero and their averages in each of the respected categories, sorted by rank bracket."
    teamHeroStatus(
        "The id of the rank bracket to include in this query, excluding all results that do not include this rank bracket."
        rankBracket: RankBracketBasicEnum!
    ): [PlusHeroTeamStatusDetailType]
}

type ProPlayerFollowType {
    activity: Int
    steamAccount: SteamAccountType
    steamAccountId: Long
}

type ProSteamAccountType {
    aliases: [String]
    birthday: Long
    countries: [String]
    facebookLink: String
    fantasyRole: Byte
    id: Long
    instagramLink: String
    isLocked: Boolean!
    isPro: Boolean!
    name: String
    position: MatchPlayerPositionType
    realName: String
    roles: Byte
    romanizedRealName: String
    signatureHeroes: [String]
    sponsor: String
    statuses: Byte
    team: TeamType
    teamId: Int
    totalEarnings: Int!
    twitchLink: String
    twitterLink: String
    vkLink: String
    weiboLink: String
    youTubeLink: String
}

type ROSHCaptainJackIdentityStatDifficultyType {
    difficulty: ROSHDifficultyEnum
    matchCount: Int
    maxScore: Float
    winCount: Int
}

type ROSHGlobalStatType {
    difficulty: ROSHDifficultyEnum
    matchCount: Int
    maxScore: Float
    winCount: Int
}

type ROSHMutation {
    create(bracket: RankBracket!, difficulty: ROSHDifficultyEnum!, isRadiantFirstPick: Boolean!, isUserRadiant: Boolean!): Long
    update(didUserWin: Boolean!, matchId: Long!, score: Float!): Boolean
}

type RabbitDetailType {
    isOnline: Boolean!
    lastUpdated: Long
    matchDetail: RabbitQueueDetailType
    matchDetailDelay: RabbitQueueDetailType
    matchHistory: RabbitQueueDetailType
    matchLive: RabbitQueueDetailType
    matchStats: RabbitQueueDetailType
    steamAccount: RabbitQueueDetailType
}

type RabbitQueueDetailType {
    queueCount: Int!
    queueInRate: Decimal
    queueOutRate: Decimal
}

type RegionType {
    clientName: String
    code: String
    displayName: String
    id: Byte
    langKey: String
    latitude: Decimal
    leaderboardDivision: String
    longitude: Decimal
    matchGroup: Byte
    name: String
    weekendTourneyDivision: String
}

type RoleType {
    langKey: String
    name: String
    roleId: Short
}

type RoshQuery {
    stats(request: ROSHMatchesRequestType): [ROSHGlobalStatType]
}

type SearchType {
    casters: [SteamAccountType]
    direTideMatches: [DireTideCustomGameMatchType]
    guild: GuildType
    leagues: [LeagueType]
    matches: [MatchType]
    players: [SteamAccountType]
    proPlayers: [SteamAccountType]
    teams: [TeamType]
}

type SeriesType {
    id: Long!
    lastMatchDateTime: Long
    league: LeagueType
    leagueId: Int
    matches: [MatchType]
    node: LeagueNodeType
    teamOne: TeamType
    teamOneId: Int
    teamOneWinCount: Short!
    teamTwo: TeamType
    teamTwoId: Int
    teamTwoWinCount: Short!
    type: Series
    winningTeamId: Int
}

type ServerStatusType {
    isRedisOnline: Boolean!
    rabbitDetail: RabbitDetailType
    steamApiDetail: SteamApiDetailType
}

type SpiritBearInventoryObjectType {
    itemId: Short
}

type SpiritBearInventoryType {
    backPack0: SpiritBearInventoryObjectType
    backPack1: SpiritBearInventoryObjectType
    backPack2: SpiritBearInventoryObjectType
    item0: SpiritBearInventoryObjectType
    item1: SpiritBearInventoryObjectType
    item2: SpiritBearInventoryObjectType
    item3: SpiritBearInventoryObjectType
    item4: SpiritBearInventoryObjectType
    item5: SpiritBearInventoryObjectType
    neutral0: SpiritBearInventoryObjectType
    teleport0: SpiritBearInventoryObjectType
    time: Int!
}

type SteamAccountBattlePassType {
    eventId: Byte
    level: Int
    steamAccountId: Long
}

type SteamAccountByRankType {
    playerCount: Int!
    rank: Short!
}

type SteamAccountNameType {
    lastSeenDateTime: Long
    name: String
}

type SteamAccountSeasonActiveLeaderboardCountryDataType {
    countryCode: String
    playerCount: Int
}

type SteamAccountSeasonActiveLeaderboardPositionDataType {
    playerCount: Int
    position: MatchPlayerPositionType
}

type SteamAccountSeasonActiveLeaderboardRankType {
    avgImp: Short
    divisionId: LeaderboardDivision
    lastUpdateDateTime: Long
    matchCount: Short
    position: MatchPlayerPositionType
    positionValue: Byte
    rank: Short
    rankShift: Short
    steamAccount: SteamAccountType
    steamAccountId: Long
    topHeroOne: Short
    topHeroThree: Short
    topHeroTwo: Short
    winRate: Byte
}

type SteamAccountSeasonActiveLeaderboardType {
    countryData: [SteamAccountSeasonActiveLeaderboardCountryDataType]
    playerCount: Int
    players(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Long,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Long
    ): [SteamAccountSeasonActiveLeaderboardRankType]
    positionData: [SteamAccountSeasonActiveLeaderboardPositionDataType]
    teamData: [TeamType]
    teamIdData: [Int]
}

type SteamAccountSeasonLeaderBoardRankType {
    asOfDateTime: Long
    rank: Short
    seasonLeaderBoardDivisionId: LeaderboardDivision
    seasonRankId: Byte
    steamAccountId: Long
}

type SteamAccountSeasonRankType {
    asOfDateTime: Long
    isCore: Boolean
    rank: Byte
    seasonRankId: Byte
}

type SteamAccountTeamMemberType {
    firstMatchDateTime: Long
    firstMatchId: Long
    lastMatchDateTime: Long
    lastMatchId: Long
    player: PlayerType
    steamAccount: SteamAccountType
    steamAccountId: Long!
    team: TeamType
    teamId: Int!
}

type SteamAccountType {
    activity: PlayerActivitySummaryType
    avatar: String
    battlepass: [SteamAccountBattlePassType]
    cityId: Int
    communityVisibleState: Int
    countryCode: String
    dotaAccountLevel: Short
    guild: GuildMemberType
    id: Long
    isAnonymous: Boolean!
    isDotaPlusSubscriber: Boolean
    isStratzPublic: Boolean!
    lastLogOff: Long
    lastMatchDateTime: Long
    lastMatchRegionId: Byte
    name: String
    primaryClanId: Long
    proSteamAccount: ProSteamAccountType
    profileUri: String
    rankShift: Short
    realName: String
    seasonLeaderboardDivisionId: Byte
    seasonLeaderboardRank: Short
    seasonRank: Byte
    smurfFlag: Byte
    stateCode: String
    timeCreated: Long
}

type SteamApiDetailOutageType {
    dateTime: Long
    secondsOffline: Int
}

type SteamApiDetailType {
    isOnline: Boolean!
    outages: [SteamApiDetailOutageType]
}

type StratzQuery {
    admin: AdminQuery
    "Returns a list of Stratz blogs."
    blogs(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [BlogType]
    "Returns a list of languages and an Id for reference. This is used throughout the site."
    languages: [LanguageType]
    "Returns a list of Stratz blogs."
    matchRetry(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        id: Long!
    ): Boolean
    "Returns a list of News Items released by Dota 2 directly."
    news: [NewsItemType]
    page: PageQuery
    search(request: FilterSearchRequestType): SearchType
    "Shows the availability to major components required in the STRATZ foundation."
    status: ServerStatusType
    "Home page data that shows the total count of players and matches in our database."
    ticker: [Int]
    user: UserQuery
}

type StreakEventType {
    heroId: Short
    time: Int!
    type: Streak
    value: Int!
}

type TI2020CustomGameRoomModifierType {
    deathCount: Int
    difficulty: AghanimLabMatchDifficultyEnum
    eliteDeathCount: Int
    eliteMatchCount: Int
    eliteWinCount: Int
    matchCount: Int
    modifierId: Short
    winCount: Int
}

type TeamPrizeType {
    league: LeagueType
    leagueId: Int
    prizeAmount: Float
    standing: Int
    team: TeamType
    teamId: Int
}

type TeamType {
    bannerLogo: String
    baseLogo: String
    coachSteamAccount: SteamAccountType
    coachSteamAccountId: Long
    countryCode: String
    countryName: String
    dateCreated: Long
    "Find match details by team id. The return is modified to group the data by the GroupBy parameter."
    heroPickBan(
        "The request object used to filter matches returned based on input criteria."
        request: HeroPickBanRequestType!
    ): [MatchPickBanGroupByType]
    id: Int!
    isLocked: Boolean
    isPro: Boolean
    lastMatchDateTime: Long
    "Find a list of all the leagues that this team has played in."
    leagues: [LeagueType]
    logo: String
    lossCount: Int
    "Find match details by leauge id."
    matches(
        "The request object used to filter matches returned based on input criteria."
        request: TeamMatchesRequestType!
    ): [MatchType]
    "Find match details by team id. The return is modified to group the data by the GroupBy parameter."
    matchesGroupBy(
        "The request object used to filter matches returned based on input criteria."
        request: PlayerMatchesGroupByRequestType!
    ): [MatchGroupByType]
    "A List of all the players for a team."
    members(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [SteamAccountTeamMemberType]
    name: String
    "Find match details by series id."
    series(
        "The request object used to filter Series returned based on input criteria."
        request: FilterSeriesRequestType!
    ): [SeriesType]
    tag: String
    url: String
    winCount: Int
}

type TopPlayersByHeroType {
    heroId: Short
    players: [PlayerLeaderBoardByHeroType]
}

type TotalMatchCountType {
    matchCount: Long
}

type TotalPlayerCountType {
    playerCount: Long
}

type TowerDamageDetailType {
    attacker: Short
    byAbility: Short
    byItem: Short
    damage: Int!
    fromNpc: Short
    npcId: Short
    time: Int!
}

type TwitchTrackerPlayerHeroType {
    heroId: Int!
    matchCount: Int!
    winCount: Int!
}

type TwitchTrackerPlayerMatchType {
    assistCount: Short
    award: Byte
    deathCount: Short
    endDateTime: Long
    heroId: Int!
    isVictory: Boolean!
    killCount: Short
    lane: MatchLaneType
    matchId: Long
    position: MatchPlayerPositionType
    role: MatchPlayerRoleType
}

type TwitchTrackerPlayerType {
    activity: PlayerBehaviorActivity
    avatar: String
    coreCountLast100: Int!
    leaderboardRank: Int
    matchCountLast100: Int!
    matches: [TwitchTrackerPlayerMatchType]
    name: String
    proPlayerName: String
    rank: Int
    steamAccountId: Long
    topHeroLast100: [TwitchTrackerPlayerHeroType]
    uniqueHeroLast100: Int!
    winCountLast100: Int!
}

type UserHomepageType {
    activeLeagueGames(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    "A list of blog components to be displayed separately on the homepage."
    blogs(
        "An array of blog ids to exclude in this query, including all results that do not include one of these blogs."
        excludedBlogIds: [Int],
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [BlogType]
    inProgressLeagues(
        "An array of league ids to exclude in this query, including all results that do not include one of these leagues."
        excludedLeagueIds: [Int],
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        includedLeagueIds: [Int],
        "An array of league tier ids to include in this query, excluding all results that do not include one of these league tiers."
        includedLeagueTierIds: [Int],
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [LeagueType]
    leagueMetas(
        "An array of league ids to exclude in this query, including all results that do not include one of these leagues."
        excludedLeagueIds: [Int],
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        includedLeagueIds: [Int],
        "An array of league tier ids to include in this query, excluding all results that do not include one of these league tiers."
        includedLeagueTierIds: [Int],
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [LeagueMetaType]
    matchAwards(
        "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
        matchPlayerAwardTypeIds: [Byte],
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    recentHighImps(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    recentMatches(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    recentRampages(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    recentWinStreaks(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    topLiveGames(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [HomepageHeroSynergyType]
    topPlayersByHeroType(
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        heroComponentsTake: Int,
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        playersTake: Int,
        "An array of rank bracket ids to include in this query, excluding all results that do not include one of these rank brackets."
        rankBracketIds: Int
    ): [TopPlayersByHeroType]
    topProPlayers(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [ProPlayerFollowType]
    topSynergiesByHero(
        "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
        heroIds: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        synergyComponentsTake: Int
    ): [HomepageHeroSynergyType]
    totalComponents: Int
    upcomingLeagues(
        "An array of league ids to exclude in this query, including all results that do not include one of these leagues."
        excludedLeagueIds: [Int],
        "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
        includedLeagueIds: [Int],
        "An array of league tier ids to include in this query, excluding all results that do not include one of these league tiers."
        includedLeagueTierIds: [Int],
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): [LeagueType]
}

type UserQuery {
    "Returns a list of feed events for the logged in user."
    feed(
        "The amount of data to skip before collecting your query. This is useful for Paging."
        skip: Int,
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int
    ): FeedResponseType
    "Gets the list of followers the person is following."
    followers: [FollowerType]
    "Gets the list of followers the person is following."
    following: [FollowerType]
    "Returns a list of Stratz blogs."
    homepage(
        "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
        take: Int!
    ): UserHomepageType
    "Find user details of the currently logged in user."
    profile: UserType
}

type UserType {
    followerCount: Int
    followingCount: Int
    followingLeagueCount: Int
    followingTeamCount: Int
    profile: CaptainJackIdentityPrivateProfileType
    recentMatch: MatchType
    steamAccount: SteamAccountType
    stratzApiApplications: [CaptainJackIdentityApiApplicationType]
}

type VendorQuery {
    dotaNext: DotaNextQuery
    "Used by the Dota 2 Twitch Tracker for Dota Stats"
    twitchTracker(
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long!
    ): TwitchTrackerPlayerType
}

type YogurtMutation {
    "Add a member to a match replay upload team. steamAccountId and matchReplayUploadTeamId are required input fields."
    addTeamMember(
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!,
        "The steam account id to include in this query, excluding all results that do not have this steam account id."
        steamAccountId: Long!
    ): Boolean
    "Create a new match replay upload team. teamName, emailAddress, and teamId are required input fields."
    createTeam(
        "The desired email address of the match replay upload team. Cannot be blank or whitespace."
        emailAddress: String!,
        "The desired team name of the match replay upload team. Cannot be blank or whitespace."
        matchReplayUploadTeamName: String!,
        "The desired dota team id of the match replay upload team. Must be a real team created in the dota client."
        teamId: Int!
    ): MatchReplayUploadTeamType
    "Delete the data of a match replay upload, removing the match replay upload from the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields."
    delete(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Import a public match as a match replay upload to the match replay upload team's data set. matchReplayUploadTeamId and matchId are required input fields."
    importMatch(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "If the Picks and Bans for a match are missing or invalid, this allows you to update them."
    importPickBans(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!,
        pickBans: [ImportPickBanType]!
    ): Boolean
    "Invalidate the data of a match replay upload, removing the match replay upload from the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields."
    invalidate(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Delete the data of a match replay upload, removing the match replay upload from the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields."
    linkSeriesId(
        "An array of Dota match ids to include in this query."
        matchIds: [Long]!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Remove the series id for all of the input matches. matchReplayUploadTeamId and matchIds are required input fields."
    removeSeriesId(
        "An array of Dota match ids to include in this query."
        matchIds: [Long]!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Remove a member of a match replay upload team. memberCaptainJackIdentityId and matchReplayUploadTeamId are required input fields."
    removeTeamMember(
        "The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id."
        captainJackIdentityId: ID!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Set the default team of a match replay upload team member. memberCaptainJackIdentityId and matchReplayUploadTeamId are required input fields."
    setTeamMemberDefaultTeam(
        "The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id."
        captainJackIdentityId: ID!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Update the data of a match replay upload. updateMatchReplayUploadObject is a required input field."
    update(
        "This object contains all of the fields a user is allowed to update on a match replay upload. Null fields are not updated. Fields set to 0 are updated to null in the database."
        updateMatchReplayUploadObject: UpdateMatchReplayUploadObjectType!
    ): Boolean
    "Update a new match replay upload team. matchReplayUploadTeamId is a required input field."
    updateTeam(
        "The desired team name of the match replay upload team. Cannot be blank or whitespace."
        matchReplayUploadTeamId: Long!,
        "The desired team name of the match replay upload team. Cannot be blank or whitespace."
        matchReplayUploadTeamName: String,
        "The desired dota team id of the match replay upload team. Must be a real team created in the dota client."
        teamId: Int
    ): Boolean
    "Update a member of a match replay upload team. memberCaptainJackIdentityId, matchReplayUploadTeamId, and isAdmin are required input fields."
    updateTeamMember(
        "The CaptainJackIdentity id to include in this query, excluding all results that do not have this CaptainJackIdentity id."
        captainJackIdentityId: ID!,
        "Whether the match replay upload team member you wish to update is an admin of that team."
        isAdmin: Boolean!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
    "Validate the data of a match replay upload, adding the match replay upload to the queryable data set associated with the match replay upload team. matchReplayUploadTeamId and matchId are required input fields."
    validate(
        "The id of the Dota match to include in this query, excluding all results that do not include this id."
        matchId: Long!,
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): Boolean
}

type YogurtQuery {
    "Find the defualt match replay upload team associated with the currently logged in user."
    defaultTeam: MatchReplayUploadTeamType
    "Find the list of Hero's in the game and determine basic output by grouping them together."
    heroSummary(
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!,
        "The request object filtering which match replay uploads to include in this query, excluding all results that do not pass through this filter."
        request: FilterMatchReplayUploadRequestType
    ): [MatchReplayUploadHeroSummaryType]
    "Find match replay uploads by match replay upload team id. matchReplayUploadTeamId and request are required input fields."
    overview(
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!,
        "The request object filtering which match replay uploads to include in this query, excluding all results that do not pass through this filter."
        request: FilterMatchReplayUploadRequestType
    ): MatchReplayUploadOverviewType
    "Find a match replay upload team by match replay upload team id. matchReplayUploadTeamId is a required input field."
    team(
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): MatchReplayUploadTeamType
    "Find match replay upload team members by match replay upload team id. matchReplayUploadTeamId is a required input field."
    teamMembers(
        "The id of the match replay upload team to include in this query, excluding all results that do not include this match replay upload team id."
        matchReplayUploadTeamId: Long!
    ): [MatchReplayUploadTeamMemberType]
    "Find all match replay upload teams associated with the currently logged in user."
    teams: [MatchReplayUploadTeamType]
}

enum AbilityDispellEnum {
    NO
    NONE
    YES
    YES_STRONG
}

enum AghanimLabDepthListAscensionAbilitiesEnum {
    AGHSFORT_ASCENSION_INVIS
    ASCENSION_ARMOR
    ASCENSION_ARMOR_SAPPING
    ASCENSION_ATTACK_SPEED
    ASCENSION_BOMB
    ASCENSION_BULWARK
    ASCENSION_CHILLING_TOUCH
    ASCENSION_CRIT
    ASCENSION_DAMAGE
    ASCENSION_DRUNKEN
    ASCENSION_EMBIGGEN
    ASCENSION_EXTRA_FAST
    ASCENSION_FIREFLY
    ASCENSION_FLICKER
    ASCENSION_HEAL_SUPPRESSION
    ASCENSION_MAGIC_IMMUNITY
    ASCENSION_MAGIC_RESIST
    ASCENSION_MAGNETIC_FIELD
    ASCENSION_METEORIC
    ASCENSION_PLASMA_FIELD
    ASCENSION_SILENCE
    ASCENSION_VAMPIRIC
    ASCENSION_VENGEANCE
}

enum AghanimLabDepthListEncounterEnum {
    ENCOUNTER_AGHANIM
    ENCOUNTER_ALCHEMIST
    ENCOUNTER_AQUA_MANOR
    ENCOUNTER_AZIYOG_CAVERNS
    ENCOUNTER_BABY_OGRES
    ENCOUNTER_BAMBOO_GARDEN
    ENCOUNTER_BANDITS
    ENCOUNTER_BEACH_TRAPS
    ENCOUNTER_BEARS_LAIR
    ENCOUNTER_BIG_OGRES
    ENCOUNTER_BLOB_DUNGEON
    ENCOUNTER_BOG_TRAPS
    ENCOUNTER_BOMBERS
    ENCOUNTER_BOMB_SQUAD
    ENCOUNTER_BONUS_CHICKEN
    ENCOUNTER_BONUS_GALLERY
    ENCOUNTER_BONUS_HOOKING
    ENCOUNTER_BONUS_LIVESTOCK
    ENCOUNTER_BONUS_MANGO_ORCHARD
    ENCOUNTER_BONUS_SMASH_CHICKENS
    ENCOUNTER_BOSS_AMOEBA
    ENCOUNTER_BOSS_ARC_WARDEN
    ENCOUNTER_BOSS_CLOCKWERK_TINKER
    ENCOUNTER_BOSS_DARK_WILLOW
    ENCOUNTER_BOSS_EARTHSHAKER
    ENCOUNTER_BOSS_RIZZRICK
    ENCOUNTER_BOSS_STOREGGA
    ENCOUNTER_BOSS_TIMBERSAW
    ENCOUNTER_BOSS_VISAGE
    ENCOUNTER_BOSS_VOID_SPIRIT
    ENCOUNTER_BOSS_WINTER_WYVERN
    ENCOUNTER_BREWMASTER
    ENCOUNTER_BRIDGE_TRAPS
    ENCOUNTER_BROODMOTHERS
    ENCOUNTER_BURNING_MESA
    ENCOUNTER_CANOPY_TRAPS
    ENCOUNTER_CASTLE_TRAPS
    ENCOUNTER_CATACOMBS
    ENCOUNTER_CAVERN_TRAPS
    ENCOUNTER_CLIFF_PASS
    ENCOUNTER_COLLAPSED_MINES
    ENCOUNTER_CRYPT_GATE
    ENCOUNTER_CRYPT_TRAPS
    ENCOUNTER_DARK_FOREST
    ENCOUNTER_DARK_SEER
    ENCOUNTER_DEEP_TRAPS
    ENCOUNTER_DEMONIC_WOODS
    ENCOUNTER_DESERT_OASIS
    ENCOUNTER_DIRE_SIEGE
    ENCOUNTER_DRAGON_KNIGHT
    ENCOUNTER_DROW_RANGER_MINIBOSS
    ENCOUNTER_DUNGEON_TRAPS
    ENCOUNTER_EGGS_HOLDOUT
    ENCOUNTER_ELEMENTAL_TINY
    ENCOUNTER_EMPTY_BEACH
    ENCOUNTER_EMPTY_CAVERN
    ENCOUNTER_ENRAGED_WILDWINGS
    ENCOUNTER_EVENT_ALCHEMIST_NEUTRAL_ITEMS
    ENCOUNTER_EVENT_BIG_TINY_GROW
    ENCOUNTER_EVENT_BREWMASTER_BAR
    ENCOUNTER_EVENT_DOOM_LIFE_SWAP
    ENCOUNTER_EVENT_LESHRAC
    ENCOUNTER_EVENT_LIFE_SHOP
    ENCOUNTER_EVENT_MINOR_SHARD_SHOP
    ENCOUNTER_EVENT_MORPHLING_ATTRIBUTE_SHIFT
    ENCOUNTER_EVENT_NAGA_BOTTLE_RUNE
    ENCOUNTER_EVENT_NECROPHOS
    ENCOUNTER_EVENT_OGRE_MAGI_CASINO
    ENCOUNTER_EVENT_SLARK
    ENCOUNTER_EVENT_SMALL_TINY_SHRINK
    ENCOUNTER_EVENT_TINKER_RANGE_RETROFIT
    ENCOUNTER_EVENT_WARLOCK_LIBRARY
    ENCOUNTER_EVENT_ZEUS
    ENCOUNTER_FIRE_ROSHAN
    ENCOUNTER_FORBIDDEN_PALACE
    ENCOUNTER_FORSAKEN_PIT
    ENCOUNTER_FRIGID_PINNACLE
    ENCOUNTER_FROZEN_RAVINE
    ENCOUNTER_GAOLERS
    ENCOUNTER_GAUNTLET
    ENCOUNTER_GOLEM_GORGE
    ENCOUNTER_HEDGE_TRAPS
    ENCOUNTER_HELLBEARS_PORTAL_V_3
    ENCOUNTER_HELLFIRE_CANYON
    ENCOUNTER_HIDDEN_COLOSSEUM
    ENCOUNTER_ICY_POOLS
    ENCOUNTER_INNER_RING
    ENCOUNTER_JUNGLE_FIRE_MAZE
    ENCOUNTER_JUNGLE_HIJINX
    ENCOUNTER_JUNGLE_TRAPS
    ENCOUNTER_JUNGLE_TREK
    ENCOUNTER_KUNKKA_TIDE
    ENCOUNTER_LEGION_COMMANDER
    ENCOUNTER_LESHRAC
    ENCOUNTER_MINING_TRAPS
    ENCOUNTER_MIRANA
    ENCOUNTER_MOLE_CAVE
    ENCOUNTER_MORPHLINGS_B
    ENCOUNTER_MORTY_TRANSITION
    ENCOUNTER_MULTIPLICITY
    ENCOUNTER_MUSHROOM_MINES
    ENCOUNTER_MUSHROOM_MINES_2021
    ENCOUNTER_MYSTICAL_TRAPS
    ENCOUNTER_NAGA_SIREN
    ENCOUNTER_OGRE_SEALS
    ENCOUNTER_OUTWORLD
    ENCOUNTER_PALACE_TRAPS
    ENCOUNTER_PANGOLIER
    ENCOUNTER_PENGUINS_TRANSITION
    ENCOUNTER_PENGUIN_SLEDDING
    ENCOUNTER_PHOENIX
    ENCOUNTER_PINECONES
    ENCOUNTER_PINE_GROVE
    ENCOUNTER_POLARITY_SWAP
    ENCOUNTER_PRIMAL_BEAST
    ENCOUNTER_PRISON_TRAPS
    ENCOUNTER_PUCKS
    ENCOUNTER_PUDGE_MINIBOSS
    ENCOUNTER_PUGNA_NETHER_REACHES
    ENCOUNTER_PUSH_PULL
    ENCOUNTER_QUILL_BEASTS
    ENCOUNTER_REGAL_TRAPS
    ENCOUNTER_ROCK_GOLEMS
    ENCOUNTER_RUINOUS_TRAPS
    ENCOUNTER_SACRED_GROUNDS
    ENCOUNTER_SALTY_SHORE
    ENCOUNTER_SHADOW_DEMONS
    ENCOUNTER_SMASHY_AND_BASHY
    ENCOUNTER_SNAPFIRE
    ENCOUNTER_SPECTRES
    ENCOUNTER_SPLITSVILLE
    ENCOUNTER_SPOOK_TOWN
    ENCOUNTER_STONEHALL_CITADEL
    ENCOUNTER_STOREGGA
    ENCOUNTER_SWAMP_OF_SADNESS
    ENCOUNTER_TEMPLE_GARDEN
    ENCOUNTER_TEMPLE_GUARDIANS
    ENCOUNTER_TEMPLE_SIEGE
    ENCOUNTER_TEMPLE_TRAPS
    ENCOUNTER_THUNDER_MOUNTAIN
    ENCOUNTER_TOXIC_TERRACE
    ENCOUNTER_TRANSITION_GATEWAY
    ENCOUNTER_TROLL_WARLORD
    ENCOUNTER_TROPICAL_KEEP
    ENCOUNTER_TUSK_SKELETONS
    ENCOUNTER_TWILIGHT_MAZE
    ENCOUNTER_UNDEAD_WOODS
    ENCOUNTER_VILLAGE_TRAPS
    ENCOUNTER_WARLOCKS
    ENCOUNTER_WAVE_BLASTERS
    ENCOUNTER_WENDIGOES
    ENCOUNTER_ZEALOT_SCARABS
}

enum AghanimLabDepthListRewardEnum {
    REWARD_TYPE_EXTRA_LIVES
    REWARD_TYPE_GOLD
    REWARD_TYPE_NONE
    REWARD_TYPE_TREASURE
}

enum AghanimLabMatchDifficultyEnum {
    APEXMAGE
    APPRENTICE
    GRANDMAGUS
    MAGICIAN
    SORCERER
}

enum AghanimLabPlayerBlessingEnum {
    ATTACK_RANGE
    BOSS_TOME
    BOTTLE_CHARGES
    BOTTLE_REGEN_DURATION
    BOTTLE_REGEN_MOVEMENT_SPEED
    CAST_RANGE
    DAMAGE_ON_STUNNED
    DEATH_DETONATION
    DEBUFF_DURATION_INCREASE
    ELITE_UPGRADE
    EXTRA_LIFE
    LOW_HP_OUTGOING_DAMAGE
    MELEE_CLEAVE
    MODIFIER_BLESSING_AGILITY
    MODIFIER_BLESSING_ARMOR
    MODIFIER_BLESSING_ATTACK_SPEED
    MODIFIER_BLESSING_BASE
    MODIFIER_BLESSING_BOOK_AGILITY
    MODIFIER_BLESSING_BOOK_INTELLIGENCE
    MODIFIER_BLESSING_BOOK_STRENGTH
    MODIFIER_BLESSING_BOTTLE_UPGRADE
    MODIFIER_BLESSING_DAMAGE_BONUS
    MODIFIER_BLESSING_DAMAGE_REFLECT
    MODIFIER_BLESSING_DETONATION
    MODIFIER_BLESSING_EVASION
    MODIFIER_BLESSING_HEALTH_BOOST
    MODIFIER_BLESSING_INTELLIGENCE
    MODIFIER_BLESSING_LIFE_STEAL
    MODIFIER_BLESSING_MAGIC_DAMAGE_BONUS
    MODIFIER_BLESSING_MAGIC_RESIST
    MODIFIER_BLESSING_MANA_BOOST
    MODIFIER_BLESSING_MOVEMENT_SPEED
    MODIFIER_BLESSING_POTION_ARCANIST
    MODIFIER_BLESSING_POTION_DRAGON
    MODIFIER_BLESSING_POTION_ECHO_SLAM
    MODIFIER_BLESSING_POTION_HEALTH
    MODIFIER_BLESSING_POTION_MANA
    MODIFIER_BLESSING_POTION_PURIFICATION
    MODIFIER_BLESSING_POTION_RAVAGE
    MODIFIER_BLESSING_POTION_SHADOW_WAVE
    MODIFIER_BLESSING_POTION_TORRENT
    MODIFIER_BLESSING_REFRESHER_SHARD
    MODIFIER_BLESSING_RESPAWN_INVULNERABILITY
    MODIFIER_BLESSING_RESPAWN_TIME_REDUCTION
    MODIFIER_BLESSING_RESTORE_MANA
    MODIFIER_BLESSING_SPELL_LIFE_STEAL
    MODIFIER_BLESSING_STRENGTH
    ORACLE_SHOP_DISCOUNT
    POTION_HEALTH
    POTION_MANA
    PROJECTILE_SPEED
    PURIFICATION_POTION
    REGEN_AROUND_ALLIES
    RESPAWN_ATTACK_SPEED
    RESPAWN_HASTE
    RESPAWN_INVULNERABILITY
    RESPAWN_TIME_REDUCTION
    ROSHAN_SHOP_DISCOUNT
    STARTING_GOLD
    START_TOME
    STAT_AGI
    STAT_DAMAGE
    STAT_EVASION
    STAT_HEALTH
    STAT_INT
    STAT_MAGIC_RESIST
    STAT_MANA
    STAT_SPELL_AMP
    STAT_STR
    UPGRADE_REROLL
}

enum BasicRegionType {
    CHINA
    EUROPE
    NORTH_AMERICA
    SEA
    SOUTH_AMERICA
}

enum BuildingType {
    BARRACKS
    FORT
    HEALER
    OUTPOST
    TOWER
}

enum Damage {
    MAGICAL
    PHYSICAL
    PURE
    UNKNOWN
}

enum Feat {
    DOTA_ACCOUNT_LEVEL
    HIGH_IMP
    RAMPAGE
    WIN_STREAK
}

enum FilterAghanimLabMatchOrderBy {
    DURATION
    END_DATE_TIME
}

enum FilterDireTide2020CustomGameMatchOrderBy {
    CANDY_SCORED
    END_DATE_TIME
}

enum FilterHeroWinRequestGroupBy {
    ALL
    HERO_ID
    HERO_ID_DURATION_MINUTES
    HERO_ID_POSITION_BRACKET
    TIME
}

enum FilterLeaderboardGuildOrderBy {
    BATTLE_PASS_LEVELS
    ID
    MEMBER_COUNT
    POINTS
    PREVIOUS_WEEK_RANK
    RANK
}

enum FilterLeaderboardOrder {
    FIRST
    LEVEL
    RECENT
}

enum FilterMatchGroupOrderByEnum {
    MATCH_COUNT
    WIN_COUNT
}

enum FilterOrder {
    ASC
    DESC
}

enum FilterOrderBy {
    ID
    LAST_MATCH_TIME
    LAST_MATCH_TIME_THEN_TIER
    NONE
    START_DATE_THEN_TIER
}

enum FilterPlayerTeammateEnum {
    AGAINST
    WITH
}

enum FindMatchPlayerGroupBy {
    ASSISTS
    AWARD
    CLUSTER
    DATE_DAY
    DEATHS
    DURATION_MINUTES
    FACTION
    GAME_MODE
    GAME_VERSION
    GOLD_PER_MINUTE
    HERO
    HERO_PERFORMANCE
    IS_INTENTIONAL_FEEDING
    IS_LEAGUE
    IS_LEAVER
    IS_PARTY
    IS_RANDOM
    IS_SERIES
    IS_STATS
    IS_VICTORY
    KILLS
    LANE
    LEAGUE_ID
    LEVEL
    LOBBY_TYPE
    POSITION
    REGION
    ROAM_LANE
    ROLE
    STEAM_ACCOUNT_ID
    STEAM_ACCOUNT_ID_AGAINST_TEAM
    STEAM_ACCOUNT_ID_HERO_ID
    STEAM_ACCOUNT_ID_HERO_ID_AGAINST_TEAM
    STEAM_ACCOUNT_ID_HERO_ID_WITH_TEAM
    STEAM_ACCOUNT_ID_WITH_TEAM
    TEAM
    TOTAL_KILLS
}

enum FindMatchPlayerList {
    AGAINST
    ALL
    SINGLE
    WITH
}

enum FindMatchPlayerOrderBy {
    ASC
    DESC
}

enum GameModeEnumType {
    ABILITY_DRAFT
    ALL_PICK
    ALL_PICK_RANKED
    ALL_RANDOM
    ALL_RANDOM_DEATH_MATCH
    BALANCED_DRAFT
    CAPTAINS_DRAFT
    CAPTAINS_MODE
    COMPENDIUM_MATCHMAKING
    CUSTOM
    EVENT
    INTRO
    LEAST_PLAYED
    MID_ONLY
    MUTATION
    NEW_PLAYER_POOL
    NONE
    RANDOM_DRAFT
    REVERSE_CAPTAINS_MODE
    SINGLE_DRAFT
    SOLO_MID
    THE_DIRETIDE
    THE_GREEVILING
    TURBO
    TUTORIAL
    UNKNOWN
}

enum GoldReason {
    ABADONS
    BOUNTY
    BUY_BACK
    COURIERS
    COURIERS_2
    CREEPS
    DEATH
    DOOM_DEVOURER
    HEROES
    NEUTRAL
    OTHER
    ROSHAN
    SELLS
    STRUCTURES
    WARD_DESTRUCTION
}

enum HeroPrimaryAttributeType {
    AGI
    ALL
    INT
    STR
}

enum HeroRoleEnum {
    CARRY
    DISABLER
    DURABLE
    ESCAPE
    INITIATOR
    JUNGLER
    NUKER
    PUSHER
    SUPPORT
}

enum LaneOutcomeEnums {
    DIRE_STOMP
    DIRE_VICTORY
    RADIANT_STOMP
    RADIANT_VICTORY
    TIE
}

enum Language {
    BRAZILIAN
    BULGARIAN
    CZECH
    DANISH
    DUTCH
    ENGLISH
    FINNISH
    FRENCH
    GERMAN
    GREEK
    HUNGARIAN
    ITALIAN
    JAPANESE
    KOREAN
    KOREANA
    NORWEGIAN
    POLISH
    PORTUGUESE
    ROMANIAN
    RUSSIAN
    SPANISH
    SWEDISH
    S_CHINESE
    THAI
    TURKISH
    T_CHINESE
    UKRAINIAN
}

enum LeaderboardDivision {
    AMERICAS
    CHINA
    EUROPE
    SE_ASIA
}

enum LeagueNodeDefaultGroupEnum {
    BEST_OF_FIVE
    BEST_OF_ONE
    BEST_OF_THREE
    BEST_OF_TWO
    INVALID
}

enum LeagueNodeGroupTypeEnum {
    BRACKET_DOUBLE_ALL_WINNER
    BRACKET_DOUBLE_SEED_LOSER
    BRACKET_SINGLE
    GSL
    INVALID
    ORGANIZATIONAL
    ROUND_ROBIN
    SHOWMATCH
    SWISS
}

enum LeagueRegion {
    CHINA
    CIS
    EUROPE
    NA
    SA
    SEA
    UNSET
}

enum LeagueStage {
    CHAMPIONS_QUALIFERS
    CLOSED_QUALIFERS
    GROUP_STAGE
    MAIN_EVENT
    OPEN_QUALIFERS
}

enum LeagueTier {
    AMATEUR
    DPC_LEAGUE
    DPC_LEAGUE_FINALS
    DPC_LEAGUE_QUALIFIER
    DPC_QUALIFIER
    INTERNATIONAL
    MAJOR
    MINOR
    PROFESSIONAL
    UNSET
}

enum LeaverStatusEnum {
    ABANDONED
    AFK
    DECLINED_READY_UP
    DISCONNECTED
    DISCONNECTED_TOO_LONG
    FAILED_TO_READY_UP
    NEVER_CONNECTED
    NEVER_CONNECTED_TOO_LONG
    NONE
}

enum LobbyTypeEnum {
    BATTLE_CUP
    COOP_VS_BOTS
    DIRE_TIDE
    EVENT
    PRACTICE
    RANKED
    SOLO_MID
    SOLO_QUEUE
    TEAM_MATCH
    TOURNAMENT
    TUTORIAL
    UNRANKED
}

enum MapLocationEnums {
    DIRE_BASE
    DIRE_FOUNTAIN
    DIRE_MID_LANE
    DIRE_OFF_LANE
    DIRE_SAFE_LANE
    RADIANT_BASE
    RADIANT_FOUNTAIN
    RADIANT_MID_LANE
    RADIANT_OFF_LANE
    RADIANT_SAFE_LANE
    RIVER
    ROAMING
    ROSHAN
}

enum MatchAnalysisOutcomeType {
    CLOSE_GAME
    COMEBACK
    NONE
    STOMPED
}

enum MatchLaneType {
    JUNGLE
    MID_LANE
    OFF_LANE
    ROAMING
    SAFE_LANE
    UNKNOWN
}

enum MatchLiveGameState {
    CUSTOM_GAME_SETUP
    DISCONNECT
    GAME_IN_PROGRESS
    HERO_SELECTION
    INIT
    LAST
    PLAYER_DRAFT
    POST_GAME
    PRE_GAME
    SCENARIO_SETUP
    STRATEGY_TIME
    TEAM_SHOWCASE
    WAIT_FOR_MAP_TO_LOAD
    WAIT_FOR_PLAYERS_TO_LOAD
}

enum MatchLiveRequestOrderBy {
    AVERAGE_RANK
    GAME_TIME
    MATCH_ID
    SPECTATOR_COUNT
}

enum MatchPlayerAward {
    MVP
    NONE
    TOP_CORE
    TOP_SUPPORT
}

enum MatchPlayerPositionType {
    ALL
    FILTERED
    POSITION_1
    POSITION_2
    POSITION_3
    POSITION_4
    POSITION_5
    UNKNOWN
}

enum MatchPlayerRoleType {
    CORE
    HARD_SUPPORT
    LIGHT_SUPPORT
    UNKNOWN
}

enum MatchPlayerTeamPickOrderType {
    FIFTH_PICK
    FIRST_PICK
    FOURTH_PICK
    SECOND_PICK
    THIRD_PICK
}

enum NeutralItemTierEnum {
    TIER_1
    TIER_2
    TIER_3
    TIER_4
    TIER_5
}

enum PatchNoteType {
    GENERAL
    GENERIC
    HERO
    ITEM
    NPC
}

enum PlayerBattlePassGroupByEnum {
    BRACKET
    COUNTRY_CODE
}

enum PlayerBehaviorActivity {
    HIGH
    INTENSE
    LOW
    MEDIUM
    NONE
    VERY_HIGH
    VERY_LOW
}

enum PlusLetterType {
    A
    B
    C
    D
    F
    S
}

enum ROSHDifficultyEnum {
    ALPHA
    EASY
    EXPERT
    HARD
    MEDIUM
}

enum RankBracket {
    ANCIENT
    ARCHON
    CRUSADER
    DIVINE
    GUARDIAN
    HERALD
    IMMORTAL
    LEGEND
    UNCALIBRATED
}

enum RankBracketBasicEnum {
    ALL
    CRUSADER_ARCHON
    DIVINE_IMMORTAL
    FILTERED
    HERALD_GUARDIAN
    LEGEND_ANCIENT
    UNCALIBRATED
}

enum RuneAction {
    BOTTLE
    PICKUP
}

enum RuneEnums {
    ARCANE
    BOUNTY
    DOUBLE_DAMAGE
    HASTE
    ILLUSION
    INVISIBILITY
    REGEN
    SHIELD
    WATER
    WISDOM
}

enum Search {
    CASTERS
    GUILDS
    LEAGUES
    MATCHES
    PLAYERS
    PRO_PLAYERS
    TEAMS
}

enum Series {
    BEST_OF_FIVE
    BEST_OF_ONE
    BEST_OF_THREE
    BEST_OF_TWO
}

enum SpawnActionType {
    DESPAWN
    SPAWN
}

enum StratzApiType {
    DATA_COLLECTOR
    MULTI_KEY
}

enum Streak {
    KILL_STREAK
    MULTI_KILL
}

enum TableCalculateEnum {
    AVERAGE
    HIGHEST
    LOWEST
    MEDIAN
}

enum WardType {
    OBSERVER
    SENTRY
}

enum XpReason {
    CREEPS
    HEROES
    OTHER
    OUTPOSTS
    ROSHAN
    TOME_OF_KNOWLEDGE
}

scalar Byte

"The `DateTime` scalar type represents a date and time. `DateTime` expects timestamps to be formatted in accordance with the [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) standard."
scalar DateTime

scalar Decimal

scalar Guid

scalar Long

scalar Short

scalar UShort

input CaptainJackIdentityProfileUpdateRequestType {
    dailyEmail: Boolean
    email: String
    emailHour: Byte
    emailLevel: Byte
    feedLevel: Byte
    isStratzPublic: Boolean
    language: Language
    monthlyEmail: Boolean
    proCircuitEmailLevel: Byte
    proCircuitFeedLevel: Byte
    themeType: Byte
    weeklyEmail: Boolean
}

input DeleteProSteamAccountRequestType {
    name: String
    realName: String
    steamAccountId: Long
}

input FilterAghanimLabHeroCompositionRequestType {
    "The base level of difficulty"
    difficulty: AghanimLabMatchDifficultyEnum!
    "If the return should be ordered by Ascending or Desending order."
    orderDirection: FilterOrder
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int
}

input FilterAghanimLabMatchRequestType {
    "The game must of been played after this set time. In Unix Time Stamp Format."
    createdAfterDateTime: Long
    "The game must of been played before this set time. In Unix Time Stamp Format."
    createdBeforeDateTime: Long
    "How far into the game (levels) they completed."
    depth: Byte
    "Required that the team playing the game won."
    didWin: Boolean
    "The base level of difficulty"
    difficulty: AghanimLabMatchDifficultyEnum
    "Return Matches that only include the set of Match Ids provided."
    matchIds: [Long]
    "The team had to make it at least this far (level)."
    minDepth: Byte
    "The order in which the data returned will be sorted by."
    orderBy: FilterAghanimLabMatchOrderBy
    "If the return should be ordered by Ascending or Desending order."
    orderDirection: FilterOrder
    "The max must be played in this list of regions"
    regionIds: [Byte]
    "To date there are two seasons of Aghanim Labyrinth. Season 1 is the Year 2020 and Season 2 is 2021."
    seasonId: Byte
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "Return matches that only include this single player."
    steamAccountId: Long
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : 100"
    take: Int
}

input FilterDireTideCustomMatchRequestType {
    "The order in which the data returned will be sorted by."
    orderBy: FilterDireTide2020CustomGameMatchOrderBy
    "If the return should be ordered by Ascending or Desending order."
    orderDirection: FilterOrder
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "The steam account id to include in this query, excluding all results that do not have this steam account id."
    steamAccountId: Long
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : 20"
    take: Int
}

input FilterHeroRampageType {
    "Only return matches after this match id. Can be used instead of Skip."
    after: Long
    "Only return matches before this match id. Can be used instead of Skip."
    before: Long
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketBasicIds: [RankBracketBasicEnum]
    "The hero id to include in this query, excluding all results that do not include this hero."
    heroId: Short!
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int!
}

input FilterLeaderboardGuildRequestType {
    "The guild was created after this date time (in Unix TimeStamp)."
    createdAfterDateTime: Long
    "The guild was created before this date time (in Unix TimeStamp)."
    createdBeforeDateTime: Long
    "If the guild is current set to 50 members."
    isFull: Boolean
    "If anyone is able to join the guild."
    isUnlocked: Boolean
    "The language required to join the guild."
    language: Byte
    "The max amount of members a guild can have."
    maxMemberCount: Byte
    "The rank required to join the guild."
    maxRequiredRank: Long
    "The amount of members a guild must have."
    memberCount: Byte
    "The minimum amount of members a guild must have."
    minMemberCount: Byte
    "The rank required to join the guild."
    minRequiredRank: Long
    "If the return should be ordered by Ascending or Desending order."
    order: FilterOrder
    "What field to order the data by. Enum values."
    orderBy: FilterLeaderboardGuildOrderBy
    "What field to order the data by. Enum values."
    region: Byte
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int
}

input FilterLeaderboardHeroRequestType {
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketIds: [RankBracket]
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int!
}

input FilterMatchReplayUploadRequestType {
    byGameMode: [Int]
    byGameVersion: [Int]
    byHeroId: [Short]
    byLeagueId: Int
    byLobbyType: [Int]
    byMatchId: Long
    byMatchIds: [Long]
    byMatchUploadFileName: String
    byMatchUploadUploaderCaptainJackId: Guid
    bySeriesId: Int
    bySeriesIds: [Long]
    bySteamAccountId: Long
    bySteamAccountIds: [Long]
    byTeamId: Int
    endDateTime: Long
    filterPosition: MatchPlayerPositionType
    filterPositionIsUs: Boolean
    filterPositionOrder: [MatchPlayerTeamPickOrderType]
    firstPick: Boolean
    isActive: Boolean
    isComplete: Boolean
    isLeague: Boolean
    isRadiant: Boolean
    isRadiantFirstPick: Boolean
    isValidated: Boolean
    isVictory: Boolean
    maxDuration: Int
    maxGameVersionId: Int
    minDuration: Int
    minGameVersionId: Int
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    startDateTime: Long
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int
    withEnemyBannedHeroId: [Short]
    withEnemyHeroId: [Short]
    withEnemySteamAccount: [Long]
    withFriendBannedHeroId: [Short]
    withFriendHeroId: [Short]
}

input FilterSearchRequestType {
    "The minimum amount of time in which a user must have played a game to be allowed inside the search query. A unix timestamp."
    lastMatchPlayedAgo: Long
    "The leaderboard is split into 4 regions. The user must appear in this region(s) for them to be allowed inside the search query."
    leaderboardRegionIds: [Byte]
    "When searching for a league, the tier the league must be in. Tiers: Amateur = 1, Professional = 2, Premium = 3, Pro Circuit = 4, Main Event = 5"
    leagueTierIds: [LeagueTier]
    "The maximum rank a player must have to be allowed inside the search query."
    maximumRank: Int
    "The minimum rank a player must have to be allowed inside the search query."
    minimumRank: Int
    "The term used to define the search parameters. Minimum input is 2 characters."
    query: String!
    "Searching our entire database can take time. If you already know what your searching for you, you can limit the query down to a set of specific types. (0 - Playuers, 1 - Matches, 2 - Leagues, 3 - Teams, 4 - ProPlayers, 5 - Casters). Default is all types."
    searchType: [Search]
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int
    "When searching for a team, only return results of those teams of which are considered Professionals."
    teamIsPro: Boolean
}

input FilterSeasonLeaderboardRequestType {
    countryCode: String
    heroId: Short
    leaderBoardDivision: LeaderboardDivision
    position: MatchPlayerPositionType
    query: String
    teamId: Int
}

input FilterSeriesRequestType {
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : 20"
    take: Int
}

input HeroPickBanRequestType {
    "Only return matches after this match id. Can be used instead of Skip."
    after: Long
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "Only return matches before this match id. Can be used instead of Skip."
    before: Long
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
}

input ImpGeneratorPlayerEventRequestType {
    assists: UShort!
    cs: UShort!
    damageReceived: Int!
    deaths: UShort!
    dn: UShort!
    healingAllies: Int!
    kills: UShort!
    level: Byte!
    magicalDamage: Int!
    neutrals: Int!
    physicalDamage: Int!
    pureDamage: Int!
    runePower: Int!
    time: Byte!
}

input ImpGeneratorPlayerRequestType {
    bracket: RankBracket!
    events: [ImpGeneratorPlayerEventRequestType]!
    heroId: Short!
    position: MatchPlayerPositionType!
}

input ImpGeneratorRequestType {
    bans: [Short]!
    isTurbo: Boolean!
    players: [ImpGeneratorPlayerRequestType]!
}

input ImportPickBanType {
    heroId: Short
    isPick: Boolean
    isRadiant: Boolean
    order: Byte
    playerSlot: Byte
    time: Byte
    wasBannedSuccessfully: Boolean
}

input LeagueMatchesRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "An array of stage type ids to include in this query, excluding all results that do not include one of these stage types."
    leagueStageTypeIds: [LeagueStage]
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The amount of matches to skip before collecting your query. Hint: Paging"
    skip: Int!
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "The steam account id to include in this query, excluding all results that do not have this steam account id."
    steamAccountId: Long
    "The amount of matches to have returned in your query. Max : "
    take: Int!
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input LeagueRequestType {
    "Determine to End value of finding a League Between two specific datetimes."
    betweenEndDateTime: Long
    "Determine to Start value of finding a League Between two specific datetimes."
    betweenStartDateTime: Long
    "If a league is set to end before this time."
    endDateTime: Long
    "Whether a league has live matches or not, represented in a boolean."
    hasLiveMatches: Boolean
    "Whether a league has started or not, represented in a boolean."
    isFutureLeague: Boolean
    "Whether a league has ended or not, represented in a boolean."
    leagueEnded: Boolean
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
    leagueIds: [Int]
    "The id to order the results by in this query."
    orderBy: FilterOrderBy
    "Whether an image is required or not, represented in a boolean."
    requireImage: Boolean
    "Whether a prize pool is required or not, represented in a boolean."
    requirePrizePool: Boolean
    "Whether a start and end date is required or not, represented in a boolean."
    requireStartAndEndDates: Boolean
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "If a league is set to start after this time."
    startDateTime: Long
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int
    "An array of tier ids to include in this query, excluding all results that do not include one of these tiers."
    tiers: [LeagueTier]
}

input MatchLiveRequestType {
    "Only return Live Matches In Progress that are currently in these states."
    gameStates: [MatchLiveGameState]
    "The hero id to include in this query, excluding all results that do not include this hero."
    heroId: Short
    "Returns only matches that are no longer active and completed but not yet deleted."
    isCompleted: Boolean
    "Returns only matches that are currently still being updated by the backend."
    isParsing: Boolean
    "Playback Data can contain a lot of information. This will only display the most recent event for each of the fields."
    lastPlaybackEventOnly: Boolean
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of league ids to include in this query, excluding all results that do not include one of these leagues."
    leagueIds: [Int]
    "The order in which the data returned will be sorted by."
    orderBy: MatchLiveRequestOrderBy
    "The amount of data to skip before collecting your query. This is useful for Paging."
    skip: Int
    "The amount to have returned in your query. The maximum of this is always dynamic. Limit : "
    take: Int
    "An array of tier ids to include in this query, excluding all results that do not include one of these tiers."
    tiers: [LeagueTier]
}

input MergeProSteamAccountRequestType {
    name: String
    realName: String
    steamAccountId: Long
}

input PlayerBreakdownRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether the match is a league match or not."
    isLeague: Boolean
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "Whether the specified player was on Radiant or not."
    isRadiant: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "Whether the match has a team assigned or not."
    isTeam: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum."
    maxDuration: Int
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least this many minutes. Default is null and there is no minimum."
    minDuration: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input."
    partyCounts: [Int]
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlayerHeroPerformanceMatchesRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether the match is a league match or not."
    isLeague: Boolean
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "Whether the specified player was on Radiant or not."
    isRadiant: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "Whether the match has a team assigned or not."
    isTeam: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    matchGroupOrderBy: FilterMatchGroupOrderByEnum
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum."
    maxDuration: Int
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least this many minutes. Default is null and there is no minimum."
    minDuration: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "If the return should be ordered by Ascending or Desending order."
    orderBy: FindMatchPlayerOrderBy
    "Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input."
    partyCounts: [Int]
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "An array of hero ids found against your team to include in this query, excluding all results that do not include one of these heroes found against team."
    withEnemyHeroIds: [Int]
    "An array of steam account ids found on the enemy team to include in this query, excluding all results that do not include one of these steam accounts found on the enemy team."
    withEnemySteamAccountIds: [Long]
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlayerHeroesPerformanceMatchesRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether the match is a league match or not."
    isLeague: Boolean
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "Whether the specified player was on Radiant or not."
    isRadiant: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "Whether the match has a team assigned or not."
    isTeam: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Requests matches where the match is no longer than this many minutes.  Default is null and there is no maximum."
    maxDuration: Int
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least this many minutes. Default is null and there is no minimum."
    minDuration: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "Matches where the user is in a party with this many friends. Automatically applys IsParty = true. This is an array input."
    partyCounts: [Int]
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "An array of hero ids found against your team to include in this query, excluding all results that do not include one of these heroes found against team."
    withEnemyHeroIds: [Int]
    "An array of steam account ids found on the enemy team to include in this query, excluding all results that do not include one of these steam accounts found on the enemy team."
    withEnemySteamAccountIds: [Long]
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlayerMatchesGroupByRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
    groupBy: FindMatchPlayerGroupBy!
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "Determines if you want a single player returned, only the player by SteamAccountId, or if you want all 10 players in the match."
    playerList: FindMatchPlayerList!
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The amount of matches to skip before collecting your query. Hint: Paging"
    skip: Int
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "The amount of matches to have returned in your query. Max : "
    take: Int!
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "An array of hero ids found against your team to include in this query, excluding all results that do not include one of these heroes found against team."
    withEnemyHeroIds: [Int]
    "An array of steam account ids found on the enemy team to include in this query, excluding all results that do not include one of these steam accounts found on the enemy team."
    withEnemySteamAccountIds: [Long]
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlayerMatchesRequestType {
    "Only return matches after this match id. Can be used instead of Skip."
    after: Long
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "Only return matches before this match id. Can be used instead of Skip."
    before: Long
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "In what order the returned data will come in."
    orderBy: FindMatchPlayerOrderBy
    "Determines if you want a single player returned, only the player by SteamAccountId, or if you want all 10 players in the match."
    playerList: FindMatchPlayerList
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The amount of matches to skip before collecting your query. Hint: Paging"
    skip: Int
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "The amount of matches to have returned in your query. Max : "
    take: Int
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "When requesting matches with a primary SteamAccountId, this will ensure that player is on specific team Id being sent in."
    teamIdSteamAccount: Int
    "A steam account id found on the enemy team to include in this query, excluding all results that do not include this steam account id found on the enemy team."
    withEnemySteamAccountIds: [Long]
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlayerPerformanceMatchesRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "Whether the match is a league match or not."
    isLeague: Boolean
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "Whether the specified player was on Radiant or not."
    isRadiant: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "Whether the match has a team assigned or not."
    isTeam: Boolean
    "Whether the match was a victory or not for the specified player."
    isVictory: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "When searching for a league, the tier the league must be in. Tiers: Amateur = 1, Professional = 2, Premium = 3, Pro Circuit = 4, Main Event = 5"
    tier: [Int]
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlayerTeammatesGroupByRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    matchGroupOrderBy: FilterMatchGroupOrderByEnum!
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Minimum amount of MatchCount required for a Duo to qualify"
    matchLimitMax: Int
    "Minimum amount of MatchCount required for a Duo to qualify"
    matchLimitMin: Int
    "Requests matches where the match is lower than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no maximum."
    maxGameVersionId: Int
    "Requests matches where the match is at least than this input.  See GameVersion API call for a list of patch ids. Default is null and there is no minimum."
    minGameVersionId: Int
    "Include only results where the main player played with popular broadcasters."
    onlyCasters: Boolean
    "Include only results where main player played with popular professionals."
    onlyPros: Boolean
    "If the return should be ordered by Ascending or Desending order."
    orderBy: FindMatchPlayerOrderBy!
    "Only used when doing matchesGroupBy endpoint.  This is how the data will be grouped and makes your return Id field."
    playerTeammateSort: FilterPlayerTeammateEnum!
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The amount of matches to skip before collecting your query. Hint: Paging"
    skip: Int
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "The amount of matches to have returned in your query. Max : "
    take: Int
    "A team id to include in this query, excluding all results that do not have this team id."
    teamId: Int
    "When requesting matches with a primary SteamAccountId, this will ensure that player is on specific team Id being sent in."
    teamIdSteamAccount: Int
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input PlusDraftMissingLetterRequestType {
    "A list of all of the banned hero ids in the draft."
    bans: Short!
    "The game mode for this type. We only support All Pick and Ranked All Pick. In the future Captain's Mode will be supported."
    gameMode: Int!
    "Due to Valve changing the way Picking has happened in the past, we require the GameVersionId so we know what version of the network to call."
    gameVersionId: Short!
    "A list of player request objects."
    players: [PlusDraftPlayerRequestType]
}

input PlusDraftPlayerRequestType {
    "When a player has selected a hero, this is the id. If a null is sent, we will send back a hero list of possible heroes."
    heroId: Short
    "The role this player will play. If a null is sent, we will assign the best possible role."
    position: MatchPlayerPositionType
    "The rank this played is.  In the event he is anonymous, use the lowest rank player in the game."
    rank: Byte
    "The slot of player. It is required to be in order from 0-9."
    slot: Int!
    "The steam id of the player. This will allow us to find player history on the player if he is not anonymous."
    steamAccountId: Long
}

input PlusDraftRequestType {
    "A list of all of the banned hero ids in the draft."
    bans: [Short]
    "The game mode for this type. We only support All Pick and Ranked All Pick. In the future Captain's Mode will be supported."
    gameMode: Int!
    "Due to Valve changing the way Picking has happened in the past, we require the GameVersionId so we know what version of the network to call."
    gameVersionId: Short!
    "The match Id or the lobby id of the match your sending.  This will cache data for the next calls to be quicker."
    matchId: Long!
    "A list of player request objects."
    players: [PlusDraftPlayerRequestType]!
}

input PlusPlayerHoverRequestType {
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "Should our Networks attempt to try to make Radiant Win the draft or Dire."
    shouldRadiantWin: MatchPlayerPositionType
    "An array of steam account ids to limit the query to only return matches with these steam account ids."
    steamAccountIds: [Long]!
    "The amount of matches to have returned in your query. Max : "
    take: Int!
}

input ROSHMatchesRequestType {
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-8 with 0 being unknown MMR and 1-8 is low to high MMR brackets. Example 7 is Divine."
    bracketIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    isCompleted: Boolean
    isRadiant: Boolean
    isUserActionFirst: Boolean
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
}

input TeamMatchesRequestType {
    "An array of award ids to include in this query, excluding all results that do not include one of these awards. The player award types include MVP (1), Top Core (2), and Top Support (3)."
    awardIds: [Int]
    "The end DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    endDateTime: Long
    "An array of game mode ids to include in this query, excluding all results that do not include one of these game modes."
    gameModeIds: [Byte]
    "An array of game version ids to include in this query, excluding all results that do not include one of these game versions."
    gameVersionIds: [Int]
    "STRATZ gives 3 players in each game an award for playing well. MVP, Top Core, Top Support (enum MatchPlayerAwardType). If you include a query of 'steamAccountId' then it will require that player to have gotten at least 1 of these awards for each match result."
    hasAward: Boolean
    "An array of hero ids to include in this query, excluding all results that do not include one of these heroes."
    heroIds: [Short]
    "Whether STRATZ has yet parsed the data of the match or not, represented in a boolean."
    isParsed: Boolean
    "Include all matches that are party games, excluding all others."
    isParty: Boolean
    "STRATZ applys an formula to determine if a game is considered 'real'. We attempt to detect AFKers, leavers, feeders, etc. 'IsStats' will return matches that do not include any of these poor quality matches."
    isStats: Boolean
    "An array of lane ids (enum MatchLaneType) to include in this query, excluding all results that do not include one of these lanes. Roaming = 0, SafeLane = 1, Midlane = 2, Offlane = 3, Jungle = 4"
    laneIds: [Int]
    "A league id to include in this query, excluding all results that do not have this league id."
    leagueId: Int
    "An array of lobby type ids to include in this query, excluding all results that do not include one of these lobby types."
    lobbyTypeIds: [Byte]
    "An array of Dota match ids to include in this query."
    matchIds: [Long]
    "Determines if you want a single player returned, only the player by SteamAccountId, or if you want all 10 players in the match."
    playerList: FindMatchPlayerList
    "An array of positions ids (enum MatchPlayerPositionType) to include in this query, excluding all results that do not include one of these lanes."
    positionIds: [MatchPlayerPositionType]
    "An array of rank ids to include in this query, excluding all results that do not include one of these ranks. The value ranges from 0-80 with 0 being unknown MMR and 1-80 is low to high MMR brackets. Example: 74 is Divine with 4 Stars."
    rankIds: [Int]
    "An array of region ids to include in this query, excluding all results that do not include one of these regions."
    regionIds: [Int]
    "An array of role ids (enum MatchPlayerRoleType) to include in this query, excluding all results that do not include one of these roles. Core = 0, Light Support = 1, Hard Support = 2"
    roleIds: [Int]
    "A series id to include in this query, excluding all results that do not have this series id."
    seriesId: Long
    "The amount of matches to skip before collecting your query. Hint: Paging"
    skip: Int!
    "The start DateTime of the Dota match(es) to include in this query, represented in unix seconds."
    startDateTime: Long
    "The steam account id to include in this query, excluding all results that do not have this steam account id."
    steamAccountId: Byte
    "The amount of matches to have returned in your query. Max : "
    take: Int!
    "An array of hero ids found on your team to include in this query, excluding all results that do not include one of these heroes found on your team."
    withFriendHeroIds: [Int]
    "An array of steam account ids found on your team to include in this query, excluding all results that do not include one of these steam accounts found on your team."
    withFriendSteamAccountIds: [Long]
}

input UpdateFollowerRequestType {
    dailyEmail: Boolean
    emailLevel: Byte
    feedLevel: Byte
    monthlyEmail: Boolean
    overrideAllUsers: Boolean!
    weeklyEmail: Boolean
}

input UpdateMatchReplayMatchUploadPlayerObjectType {
    position: MatchPlayerPositionType
    steamAccountId: Long!
}

input UpdateMatchReplayUploadObjectType {
    direTeamId: Int
    isActive: Boolean
    leagueId: Int
    matchId: Long
    matchReplayUploadTeamId: Int!
    notes: String
    players: [UpdateMatchReplayMatchUploadPlayerObjectType]
    radiantTeamId: Int
}
